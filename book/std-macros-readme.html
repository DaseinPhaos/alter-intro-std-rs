<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./chapter_1.html"><strong>1.</strong> Chapter 1</a></li><li><a href="std-macros-readme.html" class="active"><strong>2.</strong> Chapter 2</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <p>$ Standard Macros</p>
<p>Lists all the macros defined in <code>std</code>.</p>
<p>TODO:</p>
<ul>
<li>[x] categorize them.</li>
<li>[ ] add examples for the formatting macros, maybe referencing a standalone post on formatting.</li>
<li>[ ] introduce unstable macros.</li>
</ul>
<h1>Panic!</h1>
<p>First comes the Mighty Panic.</p>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.panic.html"><code>panic!</code></a></p>
<p>Injects panic into the calling thread, causing it to panic entirely.</p>
<p>Panic can be reaped as a <code>Box&lt;Any&gt;</code>.</p>
<p>Single-argument form transmits the argument, multi-argument form effectively forwards the argument to a <code>format!</code> call and transmits the returned <code>String</code>.</p>
</blockquote>
<h1>Formatting</h1>
<p>These macros are used to <code>format</code> a <code>String</code>; <code>write</code> the result to some buffer; specifically, <code>print</code> to the standard output.</p>
<p>These are among the most widely used and well-known macros defined in <code>std</code> rust, thus should be covered here first. However, the actual formatting syntax they depend on is somewhat involved, and thus will be introduced in a separate post about <a href="TODO"><code>std::fmt</code></a>.<sup class="footnote-reference"><a href="#format-rbe">1</a></sup></p>
<p>Some other macros(such as <code>assert!</code>) also utilize the formatting syntax, but as formatting is not their primary concern, they are not put under this category.</p>
<div class="footnote-definition" id="format-rbe"><sup class="footnote-definition-label">1</sup>
<p>reference to the correpsonding chapter in <a href="http://rustbyexample.com/hello/print.html">Rust by Example</a></p>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.format.html"><code>format!</code></a></p>
<p>Use the syntax described in <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a> to create a value of <code>String</code>.</p>
<p>[<code>format_args!</code>]</p>
<p>The core macro for formatted string creation. Generally not used externally.</p>
</blockquote>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.write.html"><code>write!</code></a></p>
<p>Write formatted data into a buffer.</p>
<p>The macro accepts a 'writer' (any value with a <code>write_fmt</code> method).</p>
<p>The <code>write_fmt</code> method usually comes from implementation of <code>std::fmt::Write</code> or <code>std::io::Write</code> traits.</p>
<p>Additional arguments will be formatted as presented to a <code>format!</code>.</p>
<p>Returns whatever the <code>write_fmt</code> method returns, common return values include <code>std::fmt::Result</code> of <code>std::io::Result</code>.</p>
</blockquote>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.writeln.html"><code>writeln!</code></a></p>
<p>Similar to <code>write!</code>, but appends a newline character.</p>
<p>The newline character is the LINE FEED character(<code>\n</code>, <code>U+000A</code>).</p>
</blockquote>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.print.html"><code>print!</code></a></p>
<p>Prints to the standard output using <code>format!</code> to format the input.</p>
<p>Panics if writing fails.</p>
</blockquote>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.println.html"><code>println!</code></a></p>
<p>Similar to <code>print!</code>, but appends a newline character.</p>
<p>The newline character is the LINE FEED character(<code>\n</code>, <code>U+000A</code>).</p>
</blockquote>
<h1>Assertions</h1>
<p>Assertions are runtime checks that once failed would <code>panic</code> the calling thread. They are used to check core invariants that shouldn't be violated. Also useful during testing.</p>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.assert.html"><code>assert!</code></a></p>
<p>Ensures that a boolean expression evaluates to <code>true</code> at runtime. If not, <code>panic!</code>.</p>
<p>Always checked, no matter what the build settings are. <code>debug_assert!</code> is for assertions that are not enabled in release builds by default.</p>
<p>Additional arguments to the macro will be sent to <code>format!</code> to provide a custom panic message.</p>
<p>Usage:</p>
<ul>
<li>Enforce runtime invariants (esp. for unsafe code).</li>
<li><a href="https://doc.rust-lang.org/book/testing.html">testing</a></li>
</ul>
</blockquote>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.assert_eq.html"><code>assert_eq!</code></a></p>
<p>Similar to <code>assert!($left_expr != $right_expr)</code>.</p>
</blockquote>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.assert_ne.html"><code>assert_ne!</code></a></p>
<p>Similar to <code>assert!($left_expr == $right_expr)</code>.</p>
</blockquote>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.concat.html"><code>debug_assert!</code></a></p>
<p><a href="https://doc.rust-lang.org/std/macro.debug_assert_eq.html"><code>debug_assert_eq!</code></a></p>
<p><a href="https://doc.rust-lang.org/std/macro.debug_assert_ne.html"><code>debug_assert_ne!</code></a></p>
<p>Analogies for <code>assert!</code>s, but are only evaluated in debug builds by default.</p>
<p>If <code>-C debug-assertions</code> is passed to the compiler, these assertions won't be optimized.</p>
</blockquote>
<h1>Threading</h1>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.thread_local.html"><code>thread_local</code></a></p>
<p>Declares a new thread local storage key of type <code>std::thread::LocalKey</code>.</p>
<p>The macro wraps any number of static delcarations and makes then thread local.</p>
<pre><code class="language-rust">use std::cell::RefCell;
thread_local! {
  pub static FOO: RefCell&lt;u32&gt; = RefCell::new(1);
  #[allow(unused)]
  static BAR: RefCell&lt;f32&gt; = RefCell::new(1.0);
}
</code></pre>
</blockquote>
<h1>Vector Construction</h1>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.vec.html"><code>vec!</code></a></p>
<p>Creates a <code>Vec</code> containing the arguments, allowing <code>Vec</code> to be defined with the same syntax as array exprs. It can</p>
<ul>
<li>
<p>Create a <code>Vec</code> containing a given list of elements.</p>
<pre><code class="language-rust">let v = vec![1, 2, 3];
assert_eq!(v[1], 2);
</code></pre>
</li>
<li>
<p>Create a <code>Vec</code> from a given element and size:</p>
<pre><code class="language-rust">let v = vec![1; 3];
assert_eq!(v, [1, 1, 1]);
</code></pre>
</li>
</ul>
<p>Unlike array exprs, this supports all elements implementing <code>Clone</code>.</p>
<p>This will use <code>clone()</code> to duplicate an expression.</p>
</blockquote>
<h1>The Once Mighty <code>try!</code></h1>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.try.html"><code>try!</code></a></p>
<p>Matches a <code>Result</code>. If <code>Ok</code>, expands to the wrapped value. If <code>Err</code>, retrieves the inner error, and returned it. Thus it can only be used in functions returning a <code>Result</code>.</p>
<p>This was once a popular macro. In fact, it was so popular, that the Rust team decided to introduce it into the core syntax, using <code>?</code>. Now we should always prefer using <code>?</code>.</p>
</blockquote>
<h1>Panicing Markers</h1>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.unimplemented.html"><code>unimplemented!</code></a></p>
<p>A standardized placeholder for marking unfinished code.</p>
<p>When executed, panics with msg <code>&quot;not yet implemented&quot;</code>.</p>
</blockquote>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.unreachable.html"><code>unreachable!</code></a></p>
<p>Indicating unreachable code.</p>
<p>Useful when compiler can't determine if the code is unreachable. e.g. when:</p>
<ul>
<li>Match arms with guard conditions.</li>
<li>Loops that dynamically terminate.</li>
<li>Iterators that dynamically terminate.</li>
</ul>
<p>When executed, always panics.</p>
</blockquote>
</div>
<h1>Compile-time str generation</h1>
<p>These macros can take some input tokens and turns them to some specific <code>&amp;'static str</code>s during compile time.</p>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.concat.html"><code>concat!</code></a></p>
<p>Concatenates literals into a <code>&amp;'static str</code>. Integers and floating points would be stringified.</p>
<pre><code class="language-rust">let s = concat!(&quot;test&quot;, 10, 'b', true);
assert_eq!(s, &quot;test10btrue&quot;);
</code></pre>
</blockquote>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.stringify.html"><code>stringify!</code></a></p>
<p>Stringifies the argument, yielding an expression of type <code>&amp;'static str</code>, which is the stringification of all the input tokens.</p>
<p>The expanded result is subjected to changes in the future, thus should not be relied on.</p>
<pre><code class="language-rust">// That said, we do rely on its output in the example.
let one_p_one = stringify!(1 + 1);
assert_eq!(one_p_one, &quot;1 + 1&quot;);
</code></pre>
</blockquote>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.env.html"><code>env!</code></a></p>
<p>Inspect environment variables at compile time, yielding an <code>&amp;'static str</code>.</p>
<pre><code class="language-rust">let path = env!(&quot;PATH&quot;);
println!(&quot;The PATH variable at the time of compiling was: {}&quot;, path);
</code></pre>
</blockquote>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.option_env.html"><code>option_env!</code></a></p>
<p>Similar to <code>env!</code>, but returns an <code>Option&lt;&amp;'static str&gt;</code> instead, <code>None</code> if the environment variable is not presented.</p>
</blockquote>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.file.html"><code>file!</code></a></p>
<p>Expands to the file name from which it was invoked, yielding an <code>&amp;'static str</code>.</p>
<pre><code class="language-rust">let this_filename = file!();
println!(&quot;defined in file: {}&quot;, this_filename);
</code></pre>
</blockquote>
<h1>Meta Information</h1>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.cfg.html"><code>cfg!</code></a></p>
<p>Boolean evaluation of configuration flags.</p>
<p>Syntax given to this macro is the same syntax as <a href="https://doc.rust-lang.org/reference.html#conditional-compilation">the <code>cfg</code> attribute</a>.</p>
<pre><code class="language-rust">let my_dir = if cfg!(windows) {
  &quot;windows-specified-dir&quot;
} else {
  &quot;unix-dir&quot;
};
</code></pre>
</blockquote>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.column.html"><code>column!</code></a></p>
<p>Expands to the colunmn number on which it was invoked, yielding a <code>u32</code>.</p>
</blockquote>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.line.html"><code>line!</code></a></p>
<p>Expands to the line number on which it was invoked, yielding a <code>u32</code>.</p>
</blockquote>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.module_path.html"><code>module_path!</code></a></p>
<p>Expands to a string that represents the current module path, which is a hierarchy of modules leading back up to the crate root.</p>
<p>The first component of the path returned is the name of the crate currently being compiled.</p>
<pre><code class="language-rust">mod test {
  pub fn foo() {
    assert!(module_path!().ends_with(&quot;test&quot;));
  }
}

test::foo();
</code></pre>
</blockquote>
<h1>Includes</h1>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.include.html"><code>include!</code></a></p>
<p>Parse a file as an expression or an item according to context.</p>
<p>Path is located relative to the current file.</p>
<p>Using this macro is often considered a bad idea.</p>
</blockquote>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.include_bytes.html"><code>include_bytes!</code></a></p>
<p>Include a file as a reference to a byte array, yielding a <code>&amp;'static [u8; N]</code> which is the contents of the referenced file.</p>
<p>Path is located relative to the current file.</p>
</blockquote>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.include_str.html"><code>include_str!</code></a></p>
<p>Include a utf8 encoded file as a string, yielding a <code>&amp;'static str</code> which is the contents of the referenced file.</p>
<p>Path is located relative to the current file.</p>
</blockquote>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="./chapter_1.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                

            </div>

            
                <a href="./chapter_1.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
