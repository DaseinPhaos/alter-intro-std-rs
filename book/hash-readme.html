<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>std::hash</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ol class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='macros-readme.html'><b>2.</b> Macros in std</a>
</li>
<li><a  href='mods-readme.html'><b>3.</b> Uncategorized Modules</a>
<ol class='section'>
<li><a  href='any-readme.html'><b>3.1.</b> std::any</a>
</li>
<li><a  href='ascii-readme.html'><b>3.2.</b> std::ascii</a>
</li>
<li><a  href='borrow-readme.html'><b>3.3.</b> std::borrow</a>
</li>
<li><a  href='boxed-readme.html'><b>3.4.</b> std::boxed</a>
</li>
<li><a  href='cell-readme.html'><b>3.5.</b> std::cell</a>
</li>
<li><a  href='clone-readme.html'><b>3.6.</b> std::clone</a>
</li>
<li><a  href='cmp-readme.html'><b>3.7.</b> std::cmp</a>
</li>
<li><a  href='collections-readme.html'><b>3.8.</b> std::collections</a>
</li>
<li><a  href='convert-readme.html'><b>3.9.</b> std::convert</a>
</li>
<li><a  href='default-readme.html'><b>3.10.</b> std::default</a>
</li>
<li><a  href='env-readme.html'><b>3.11.</b> std::env</a>
</li>
<li><a  href='error-readme.html'><b>3.12.</b> std::error</a>
</li>
<li><a  href='ffi-readme.html'><b>3.13.</b> std::ffi</a>
</li>
<li><a  href='fmt-readme.html'><b>3.14.</b> std::fmt</a>
</li>
<li><a  href='fs-readme.html'><b>3.15.</b> std::fs</a>
</li>
<li><a class='active' href='hash-readme.html'><b>3.16.</b> std::hash</a>
</li>
<li><a  href='io-readme.html'><b>3.17.</b> std::io</a>
</li>
<li><a  href='iter-readme.html'><b>3.18.</b> std::iter</a>
</li>
<li><a  href='marker-readme.html'><b>3.19.</b> std::marker</a>
</li>
</ol>
</li>
</ol>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">std::hash</h1>
    <blockquote>
<p><a href="https://doc.rust-lang.org/std/hash/">https://doc.rust-lang.org/std/hash/</a></p>
</blockquote>

<p>The module provides generic hashing support.</p>

<p>A <a href="https://en.wikipedia.org/wiki/Hash_function">hash function</a> is a function that maps an arbitrary sized datum to a fixed-sized datum. The first trait defined in this module represents such a function object:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Hasher</span> {
    <span class='kw'>fn</span> <span class='ident'>write</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>bytes</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>u8</span>]);
    <span class='kw'>fn</span> <span class='ident'>finish</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>u64</span>;
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20trait%20Hasher%20%7B%0A%20%20%20%20fn%20write(%26mut%20self%2C%20bytes%3A%20%26%5Bu8%5D)%3B%0A%20%20%20%20fn%20finish(%26self)%20-%3E%20u64%3B%0A%7D%0A%7D">Run</a></pre>

<p>The trait requires the above two methods to be implemented. <code>write</code> writes some input into the <code>Hasher</code>. Such writing can be accumulated, until a <code>finish</code> is invoked, yielding the final hashed value of the preceding data stream, as a <code>u64</code>.</p>

<p>With the <code>write</code> method defined, the trait provides implementations for writing numeric type data:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Hasher</span> {
    <span class='comment'>// ...</span>
    <span class='kw'>fn</span> <span class='ident'>write_u8</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>i</span>: <span class='ident'>u8</span>) { ... }
    <span class='kw'>fn</span> <span class='ident'>write_u16</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>i</span>: <span class='ident'>u16</span>) { ... }
    <span class='kw'>fn</span> <span class='ident'>write_u32</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>i</span>: <span class='ident'>u32</span>) { ... }
    <span class='kw'>fn</span> <span class='ident'>write_u64</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>i</span>: <span class='ident'>u64</span>) { ... }
    <span class='kw'>fn</span> <span class='ident'>write_usize</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>i</span>: <span class='ident'>usize</span>) { ... }
    <span class='kw'>fn</span> <span class='ident'>write_i8</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>i</span>: <span class='ident'>i8</span>) { ... }
    <span class='kw'>fn</span> <span class='ident'>write_i16</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>i</span>: <span class='ident'>i16</span>) { ... }
    <span class='kw'>fn</span> <span class='ident'>write_i32</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>i</span>: <span class='ident'>i32</span>) { ... }
    <span class='kw'>fn</span> <span class='ident'>write_i64</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>i</span>: <span class='ident'>i64</span>) { ... }
    <span class='kw'>fn</span> <span class='ident'>write_isize</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>i</span>: <span class='ident'>isize</span>) { ... }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20trait%20Hasher%20%7B%0A%20%20%20%20%2F%2F%20...%0A%20%20%20%20fn%20write_u8(%26mut%20self%2C%20i%3A%20u8)%20%7B%20...%20%7D%0A%20%20%20%20fn%20write_u16(%26mut%20self%2C%20i%3A%20u16)%20%7B%20...%20%7D%0A%20%20%20%20fn%20write_u32(%26mut%20self%2C%20i%3A%20u32)%20%7B%20...%20%7D%0A%20%20%20%20fn%20write_u64(%26mut%20self%2C%20i%3A%20u64)%20%7B%20...%20%7D%0A%20%20%20%20fn%20write_usize(%26mut%20self%2C%20i%3A%20usize)%20%7B%20...%20%7D%0A%20%20%20%20fn%20write_i8(%26mut%20self%2C%20i%3A%20i8)%20%7B%20...%20%7D%0A%20%20%20%20fn%20write_i16(%26mut%20self%2C%20i%3A%20i16)%20%7B%20...%20%7D%0A%20%20%20%20fn%20write_i32(%26mut%20self%2C%20i%3A%20i32)%20%7B%20...%20%7D%0A%20%20%20%20fn%20write_i64(%26mut%20self%2C%20i%3A%20i64)%20%7B%20...%20%7D%0A%20%20%20%20fn%20write_isize(%26mut%20self%2C%20i%3A%20isize)%20%7B%20...%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Internally, these functions make use of the <code>write</code> method, as we&#39;d expect.</p>

<p>With hashing functions abstracted as <code>Hasher</code>s, to actually define a hashable type, one simply implements <code>Hash</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Hash</span> {
    <span class='kw'>fn</span> <span class='ident'>hash</span><span class='op'>&lt;</span><span class='ident'>H</span>: <span class='ident'>Hasher</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>state</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>H</span>);

    <span class='kw'>fn</span> <span class='ident'>hash_slice</span><span class='op'>&lt;</span><span class='ident'>H</span>: <span class='ident'>Hasher</span><span class='op'>&gt;</span>(<span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='self'>Self</span>], <span class='ident'>state</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>H</span>) <span class='kw'>where</span> <span class='self'>Self</span>: <span class='ident'>Sized</span> {
        <span class='kw'>for</span> <span class='ident'>piece</span> <span class='kw'>in</span> <span class='ident'>data</span> {
            <span class='ident'>piece</span>.<span class='ident'>hash</span>(<span class='ident'>state</span>);
        }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20trait%20Hash%20%7B%0A%20%20%20%20fn%20hash%3CH%3A%20Hasher%3E(%26self%2C%20state%3A%20%26mut%20H)%3B%0A%0A%20%20%20%20fn%20hash_slice%3CH%3A%20Hasher%3E(data%3A%20%26%5BSelf%5D%2C%20state%3A%20%26mut%20H)%20where%20Self%3A%20Sized%20%7B%0A%20%20%20%20%20%20%20%20for%20piece%20in%20data%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20piece.hash(state)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>The required method <code>hash</code> should be implemented such that, given a hashing function object <code>state</code>, the value of the object is written into it. One can also use the <code>#[derive]</code> attribute with this trait to implement an default hashing strategy, if all fields of the type implement <code>Hash</code>. The resulting hash will be the combination of calling <code>hash</code> on each field. Most of the primitive types implements <code>Hash</code>.</p>

<p>The default-implemented method <code>hash_slice</code> hashes a slice of <code>Self</code>.</p>

<p>Most of the primitive types and a lot of other types in the <code>std</code> implement <code>Hash</code>.</p>

<p>Additionally, the module also defines a <code>BuuldHasher</code>, which can be considered as a factory-like interface for building hashing function objects(i.e. <code>Hasher</code>s). It is defined as:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>BuuldHasher</span> {
    <span class='kw'>type</span> <span class='ident'>Hasher</span>: <span class='ident'>Hasher</span>;
    <span class='kw'>fn</span> <span class='ident'>build_hasher</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='self'>Self</span>::<span class='ident'>Hasher</span>;
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20trait%20BuuldHasher%20%7B%0A%20%20%20%20type%20Hasher%3A%20Hasher%3B%0A%20%20%20%20fn%20build_hasher(%26self)%20-%3E%20Self%3A%3AHasher%3B%0A%7D%0A%7D">Run</a></pre>

<p>Note that, for each instance of a <code>BuildHasher</code>, the hashers it create should be identical in the hashing behavior.</p>

<p>The module also provides <code>BuildHasherDefault</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>BuildHasherDefault</span><span class='op'>&lt;</span><span class='ident'>H</span><span class='op'>&gt;</span>(<span class='ident'>marker</span>::<span class='ident'>PhantomData</span><span class='op'>&lt;</span><span class='ident'>H</span><span class='op'>&gt;</span>);

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>H</span><span class='op'>&gt;</span> <span class='ident'>BuildHasher</span> <span class='kw'>for</span> <span class='ident'>BuildHasherDefault</span><span class='op'>&lt;</span><span class='ident'>H</span><span class='op'>&gt;</span> <span class='kw'>where</span> <span class='ident'>H</span>: <span class='ident'>Default</span> <span class='op'>+</span> <span class='ident'>Hasher</span> {
    <span class='kw'>type</span> <span class='ident'>Hasher</span> <span class='op'>=</span> <span class='ident'>H</span>;
    <span class='kw'>fn</span> <span class='ident'>build_hasher</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>H</span> {
        <span class='ident'>H</span>::<span class='ident'>default</span>()
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20struct%20BuildHasherDefault%3CH%3E(marker%3A%3APhantomData%3CH%3E)%3B%0A%0Aimpl%3CH%3E%20BuildHasher%20for%20BuildHasherDefault%3CH%3E%20where%20H%3A%20Default%20%2B%20Hasher%20%7B%0A%20%20%20%20type%20Hasher%20%3D%20H%3B%0A%20%20%20%20fn%20build_hasher(%26self)%20-%3E%20H%20%7B%0A%20%20%20%20%20%20%20%20H%3A%3Adefault()%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>for <code>H: Hasher</code> that also implements <code>Default</code>. The method simply returns that default value.</p>

<p>The struct also implements <code>Debug</code>, <code>Clone</code> and <code>Default</code>.</p>

    <script src='rustbook.js'></script>
</div></div>


</body>
</html>