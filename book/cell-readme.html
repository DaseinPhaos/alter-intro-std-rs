<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>std::cell</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ol class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='macros-readme.html'><b>2.</b> Macros in std</a>
</li>
<li><a  href='mods-readme.html'><b>3.</b> Uncategorized Modules</a>
<ol class='section'>
<li><a  href='any-readme.html'><b>3.1.</b> std::any</a>
</li>
<li><a  href='ascii-readme.html'><b>3.2.</b> std::ascii</a>
</li>
<li><a  href='borrow-readme.html'><b>3.3.</b> std::borrow</a>
</li>
<li><a  href='boxed-readme.html'><b>3.4.</b> std::boxed</a>
</li>
<li><a class='active' href='cell-readme.html'><b>3.5.</b> std::cell</a>
</li>
<li><a  href='clone-readme.html'><b>3.6.</b> std::clone</a>
</li>
<li><a  href='cmp-readme.html'><b>3.7.</b> std::cmp</a>
</li>
<li><a  href='collections-readme.html'><b>3.8.</b> std::collections</a>
</li>
<li><a  href='convert-readme.html'><b>3.9.</b> std::convert</a>
</li>
<li><a  href='default-readme.html'><b>3.10.</b> std::default</a>
</li>
<li><a  href='env-readme.html'><b>3.11.</b> std::env</a>
</li>
<li><a  href='error-readme.html'><b>3.12.</b> std::error</a>
</li>
<li><a  href='ffi-readme.html'><b>3.13.</b> std::ffi</a>
</li>
<li><a  href='fmt-readme.html'><b>3.14.</b> std::fmt</a>
</li>
<li><a  href='fs-readme.html'><b>3.15.</b> std::fs</a>
</li>
<li><a  href='hash-readme.html'><b>3.16.</b> std::hash</a>
</li>
<li><a  href='io-readme.html'><b>3.17.</b> std::io</a>
</li>
<li><a  href='iter-readme.html'><b>3.18.</b> std::iter</a>
</li>
<li><a  href='marker-readme.html'><b>3.19.</b> std::marker</a>
</li>
<li><a  href='mem-readme.html'><b>3.20.</b> std::mem</a>
</li>
<li><a  href='net-readme.html'><b>3.21.</b> std::net</a>
</li>
<li><a  href='num-readme.html'><b>3.22.</b> std::num</a>
</li>
<li><a  href='ops-readme.html'><b>3.23.</b> std::ops</a>
</li>
<li><a  href='option-readme.html'><b>3.24.</b> std::option</a>
</li>
<li><a  href='os-readme.html'><b>3.25.</b> std::os</a>
</li>
<li><a  href='panic-readme.html'><b>3.26.</b> std::panic</a>
</li>
<li><a  href='path-readme.html'><b>3.27.</b> std::path</a>
</li>
<li><a  href='prelude-readme.html'><b>3.28.</b> std::prelude</a>
</li>
<li><a  href='process-readme.html'><b>3.29.</b> std::process</a>
</li>
</ol>
</li>
</ol>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">std::cell</h1>
    <blockquote>
<p><a href="https://doc.rust-lang.org/std/cell/">https://doc.rust-lang.org/std/cell/</a></p>
</blockquote>

<p>This module introduces &quot;interior mutability&quot; into the language. There is <a href="https://doc.rust-lang.org/book/mutability.html">a section</a> in The Book which is dedicated to explaining this matter.</p>

<h1 id='unsafecell' class='section-header'><a href='#unsafecell'>UnsafeCell</a></h1>
<p>To really understand what&#39;s going on under the hood, we should take a look at <code>UnsafeCell&lt;T&gt;</code> first:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>lang</span> <span class='op'>=</span> <span class='string'>&quot;unsafe_cell&quot;</span>]</span>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>UnsafeCell</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='question-mark'>?</span><span class='ident'>Sized</span><span class='op'>&gt;</span> {
    <span class='ident'>value</span>: <span class='ident'>T</span>,
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='question-mark'>?</span><span class='ident'>Sized</span><span class='op'>&gt;</span> <span class='op'>!</span><span class='ident'>Sync</span> <span class='kw'>for</span> <span class='ident'>UnsafeCell</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>UnsafeCell</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='attribute'>#[<span class='ident'>inline</span>]</span>
    <span class='kw'>pub</span> <span class='kw'>const</span> <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>value</span>: <span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='ident'>UnsafeCell</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
        <span class='ident'>UnsafeCell</span> { <span class='ident'>value</span>: <span class='ident'>value</span> }
    }

    <span class='attribute'>#[<span class='ident'>inline</span>]</span>
    <span class='kw'>pub</span> <span class='kw'>unsafe</span> <span class='kw'>fn</span> <span class='ident'>into_inner</span>(<span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>T</span> {
        <span class='self'>self</span>.<span class='ident'>value</span>
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='question-mark'>?</span><span class='ident'>Sized</span><span class='op'>&gt;</span> <span class='ident'>UnsafeCell</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='attribute'>#[<span class='ident'>inline</span>]</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>*</span><span class='kw-2'>mut</span> <span class='ident'>T</span> {
        <span class='kw-2'>&amp;</span><span class='self'>self</span>.<span class='ident'>value</span> <span class='kw'>as</span> <span class='kw-2'>*</span><span class='kw'>const</span> <span class='ident'>T</span> <span class='kw'>as</span> <span class='kw-2'>*</span><span class='kw-2'>mut</span> <span class='ident'>T</span>
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%23%5Blang%20%3D%20%22unsafe_cell%22%5D%0Apub%20struct%20UnsafeCell%3CT%3A%20%3FSized%3E%20%7B%0A%20%20%20%20value%3A%20T%2C%0A%7D%0A%0Aimpl%3CT%3A%20%3FSized%3E%20!Sync%20for%20UnsafeCell%3CT%3E%20%7B%7D%0A%0Aimpl%3CT%3E%20UnsafeCell%3CT%3E%20%7B%0A%20%20%20%20%23%5Binline%5D%0A%20%20%20%20pub%20const%20fn%20new(value%3A%20T)%20-%3E%20UnsafeCell%3CT%3E%20%7B%0A%20%20%20%20%20%20%20%20UnsafeCell%20%7B%20value%3A%20value%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20%23%5Binline%5D%0A%20%20%20%20pub%20unsafe%20fn%20into_inner(self)%20-%3E%20T%20%7B%0A%20%20%20%20%20%20%20%20self.value%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%3CT%3A%20%3FSized%3E%20UnsafeCell%3CT%3E%20%7B%0A%20%20%20%20%23%5Binline%5D%0A%20%20%20%20pub%20fn%20get(%26self)%20-%3E%20*mut%20T%20%7B%0A%20%20%20%20%20%20%20%20%26self.value%20as%20*const%20T%20as%20*mut%20T%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Generally speaking, when the compiler is doing its job, it&#39;d make optimizations to the code based on the knowledge that a <code>&amp;T</code> is not mutably aliased or mutated, and that a <code>&amp;mut T</code> is the unique mutating reference to its referent. As such, transmuting an <code>&amp;T</code> into an <code>&amp;mut T</code> is considered undefined behavior, because it violates the compiler&#39;s assumption about data mutability.</p>

<p>However, interior mutability by its nature <em>is</em> such a violation. To inform the compiler to turn off related optimizations(thus remove the undefinedness), we have no way but to perform some magic. The <code>#[lang = &quot;unsafe_cell&quot;]</code> attribute is exactly that magic, making <code>UnsafeCell&lt;T&gt;</code> the only legal building block for interior mutability in the language. When an <code>UnsafeCell&lt;T&gt;</code> is immutably aliased, it&#39;s still safe to obtain mutable reference to its interior <code>value: T</code> and/or to mutate it.</p>

<p>However, it is now up to the user to ensure that, no two mutable references obtained this way are active at the same time, and that there are no active mutable reference whe an immutable reference is obtained from the cell. This is why the <code>get</code> method returns a raw pointer, and the <code>into_inner</code> is being marked as <code>unsafe</code>.</p>

<p>Another thing to notice is that, what this magical cell provides is only the ability to mutating or mutably aliasing the contents of an <code>&amp;UnsafeCell&lt;T&gt;</code>. Nothing else. Any other kind of violation to Rust&#39;s mutability system, say, having multiple <code>&amp;mut UnsafeCell&lt;T&gt;</code> referencing the same referent simultaneously, is still undefined behavior.</p>

<p>Additionally, note that <code>UnsafeCell&lt;T&gt;</code> implements <code>From&lt;T&gt;</code>. It also implements <code>Default</code> and/or <code>Debug</code> when <code>T</code> implements those traits, respectively.</p>

<p>One thing to keep in mind is that, <code>!Sync</code> is also implemented for <code>UnsafeCell&lt;T&gt;</code>, meaning that by default this is only intended for single-threaded scenarios. The reason should be obvious if you&#39;re familiar with multithread programming and Rust&#39;s safely promise. Same thing goes for <code>Cell</code> and <code>RefCell</code>, which we are going to cover next.</p>

<h1 id='cell' class='section-header'><a href='#cell'>Cell</a></h1>
<p>On top of <code>UnsafeCell</code>, lies the &quot;safe&quot; <code>Cell</code> for safe code to use:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Cell</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>value</span>: <span class='ident'>UnsafeCell</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>,
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Copy</span><span class='op'>&gt;</span> <span class='ident'>Cell</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='attribute'>#[<span class='ident'>inline</span>]</span>
    <span class='kw'>pub</span> <span class='kw'>const</span> <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>value</span>: <span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='ident'>Cell</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
        <span class='ident'>Cell</span> { <span class='ident'>value</span>: <span class='ident'>UnsafeCell</span>::<span class='ident'>new</span>(<span class='ident'>value</span>) }
    }

    <span class='attribute'>#[<span class='ident'>inline</span>]</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>T</span> {
        <span class='kw'>unsafe</span>{ <span class='kw-2'>*</span><span class='self'>self</span>.<span class='ident'>value</span>.<span class='ident'>get</span>() }
    }

    <span class='attribute'>#[<span class='ident'>inline</span>]</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>set</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>value</span>: <span class='ident'>T</span>) {
        <span class='kw'>unsafe</span> { <span class='kw-2'>*</span><span class='self'>self</span>.<span class='ident'>value</span>.<span class='ident'>get</span>() <span class='op'>=</span> <span class='ident'>value</span>; }
    }

    <span class='attribute'>#[<span class='ident'>inline</span>]</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>as_ptr</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>*</span><span class='kw-2'>mut</span> <span class='ident'>T</span> {
        <span class='self'>self</span>.<span class='ident'>value</span>.<span class='ident'>get</span>()
    }

    <span class='attribute'>#[<span class='ident'>inline</span>]</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>get_mut</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>T</span> {
        <span class='kw'>unsafe</span> { <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='kw-2'>*</span><span class='self'>self</span>.<span class='ident'>value</span>.<span class='ident'>get</span>() }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20struct%20Cell%3CT%3E%20%7B%0A%20%20%20%20value%3A%20UnsafeCell%3CT%3E%2C%0A%7D%0A%0Aimpl%3CT%3A%20Copy%3E%20Cell%3CT%3E%20%7B%0A%20%20%20%20%23%5Binline%5D%0A%20%20%20%20pub%20const%20fn%20new(value%3A%20T)%20-%3E%20Cell%3CT%3E%20%7B%0A%20%20%20%20%20%20%20%20Cell%20%7B%20value%3A%20UnsafeCell%3A%3Anew(value)%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20%23%5Binline%5D%0A%20%20%20%20pub%20fn%20get(%26self)%20-%3E%20T%20%7B%0A%20%20%20%20%20%20%20%20unsafe%7B%20*self.value.get()%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20%23%5Binline%5D%0A%20%20%20%20pub%20fn%20set(%26self%2C%20value%3A%20T)%20%7B%0A%20%20%20%20%20%20%20%20unsafe%20%7B%20*self.value.get()%20%3D%20value%3B%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20%23%5Binline%5D%0A%20%20%20%20pub%20fn%20as_ptr(%26self)%20-%3E%20*mut%20T%20%7B%0A%20%20%20%20%20%20%20%20self.value.get()%0A%20%20%20%20%7D%0A%0A%20%20%20%20%23%5Binline%5D%0A%20%20%20%20pub%20fn%20get_mut(%26mut%20self)%20-%3E%20%26mut%20T%20%7B%0A%20%20%20%20%20%20%20%20unsafe%20%7B%20%26mut%20*self.value.get()%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p><code>Cell&lt;T&gt;</code> is designed for <code>T: Copy</code> to use. It&#39;s <code>set</code> method allows the celled value to be mutated through an <code>&amp; self</code>. </p>

<p>Note that, instead of returning an <code>&amp;T</code>, which, under this case of interior mutability can&#39;t guarantee that its referent is actually immutable; the <code>get</code> method returns a copy of the celled value. As such, while the returned value is indeed an equivalent of the celled value, Safe Rust&#39;s assumption about mutability has also been maintained. </p>

<p>Note that the <code>get_mut</code> method requires a <code>&amp;mut self</code>. This behavior is in consistent with our statement above that, interior mutability only introduces mutation through immutable reference, <em>not</em> mutation through multiple mutable reference. That is to say, the following code will still fail to compile, as we&#39;d normally expect:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cell</span>::<span class='ident'>Cell</span>;
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>mutable</span> <span class='op'>=</span> <span class='ident'>Cell</span>::<span class='ident'>new</span>(<span class='number'>1</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>mutable</span>);
    <span class='kw'>let</span> <span class='ident'>mutable_ref</span> <span class='op'>=</span> <span class='ident'>mutable</span>.<span class='ident'>get_mut</span>();
    <span class='kw-2'>*</span><span class='ident'>mutable_ref</span> <span class='op'>=</span> <span class='number'>2</span>;
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>mutable_ref</span>);
    <span class='kw'>let</span> <span class='ident'>mutable_ref_2</span> <span class='op'>=</span> <span class='ident'>mutable</span>.<span class='ident'>get_mut</span>();
    <span class='kw-2'>*</span><span class='ident'>mutable_ref</span> <span class='op'>=</span> <span class='number'>3</span>;
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>mutable_ref_2</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%20%20%20%20use%20std%3A%3Acell%3A%3ACell%3B%0A%20%20%20%20let%20mut%20mutable%20%3D%20Cell%3A%3Anew(1)%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20mutable)%3B%0A%20%20%20%20let%20mutable_ref%20%3D%20mutable.get_mut()%3B%0A%20%20%20%20*mutable_ref%20%3D%202%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20mutable_ref)%3B%0A%20%20%20%20let%20mutable_ref_2%20%3D%20mutable.get_mut()%3B%0A%20%20%20%20*mutable_ref%20%3D%203%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20mutable_ref_2)%3B%0A%7D%0A">Run</a></pre>

<p>Compiling the code fragment above (under rustc 1.14.0) would fail with something like:</p>

<pre><code class="language-text">error[E0499]: cannot borrow `mutable` as mutable more than once at a time
   --&gt; src\main.rs:8:25
    |
  4 |     let mutable_ref = mutable.get_mut();
    |                       ------- first mutable borrow occurs here
...
  8 |     let mutable_ref_2 = mutable.get_mut();
    |                         ^^^^^^^ second mutable borrow occurs here
...
 11 | }
    | - first borrow ends here
</code></pre>

<p>Also note that <code>Cell&lt;T&gt;</code> implements <code>Clone</code>, <code>From&lt;T&gt;</code> and <code>!Sync</code>. Additionally, it implements <code>Eq</code>, <code>PartialOrd&lt;Cell&lt;T&gt;&gt;</code>, <code>PartialEq&lt;Cell&lt;T&gt;&gt;</code>, <code>Send</code>, <code>Ord</code>, <code>Default</code>, <code>Debug</code> when <code>T</code> implements those triats, respectively.</p>

<h1 id='refcell' class='section-header'><a href='#refcell'>RefCell</a></h1>
<p>Remember that, <code>UnsafeCell&lt;T&gt;</code> requires its <code>unsafe</code> user to guarantee that Safe Rust&#39;s mutability model wouldn&#39;t be violated. Now the thing is, with interior mutability kicking in, Safe Rust&#39;s conventional way of referencing things immutably, <code>&amp; T</code>, actually cannot guarantee the immutability of its referent. As such, <code>&amp; T</code> can no longer be directly used by Safe Rust. For <code>T: Copy</code>, <code>Cell&lt;T&gt;</code> gets away by returning a copy; for uncopyable types however, we need something more than that.</p>

<p>Standard library introduces <code>RefCell&lt;T&gt;</code>(with a bunch of related types) for this. It uses Rust&#39;s lifetime to implement &#39;dynamic borrowing&#39;, where one can claim temporary, exclusive, mutable access to the inner value. Such borrowing are tracked at runtime, so that Rust&#39;s mutability model won&#39;t be actually violated. As such, interior mutability is safely introduced into a wider scope.</p>

<p>Its implementation is also a good demonstration for <code>Cell</code>&#39;s usage, so let&#39;s take a look:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>type</span> <span class='ident'>BorrowFlag</span> <span class='op'>=</span> <span class='ident'>usize</span>;
<span class='kw'>const</span> <span class='ident'>UNUSED</span>: <span class='ident'>BorrowFlag</span> <span class='op'>=</span> <span class='number'>0</span>;
<span class='kw'>const</span> <span class='ident'>WRITING</span>: <span class='ident'>BorrowFlag</span> <span class='op'>=</span> <span class='op'>!</span><span class='number'>0</span>;

<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>RefCell</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='question-mark'>?</span><span class='ident'>Sized</span><span class='op'>&gt;</span> {
    <span class='ident'>borrow</span>: <span class='ident'>Cell</span><span class='op'>&lt;</span><span class='ident'>BorrowFlag</span><span class='op'>&gt;</span>,
    <span class='ident'>value</span>: <span class='ident'>UnsafeCell</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>,
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atype%20BorrowFlag%20%3D%20usize%3B%0Aconst%20UNUSED%3A%20BorrowFlag%20%3D%200%3B%0Aconst%20WRITING%3A%20BorrowFlag%20%3D%20!0%3B%0A%0Apub%20struct%20RefCell%3CT%3A%20%3FSized%3E%20%7B%0A%20%20%20%20borrow%3A%20Cell%3CBorrowFlag%3E%2C%0A%20%20%20%20value%3A%20UnsafeCell%3CT%3E%2C%0A%7D%0A%7D">Run</a></pre>

<p>As we can see inside <code>RefCell&lt;T&gt;</code>, in addition to the <code>value: UnsafeCell&lt;T&gt;</code> field where the actual value is stored, the <code>borrow: Cell&lt;BorrowFlag&gt;</code> field represents a flag indicating how the value is currently being dynamically borrowed. As such, logically speaking, the <code>borrow</code> flag shouldn&#39;t get involved in the (static) mutability consideration of <code>RefCell&lt;T&gt;</code>, thus it is wrapped in a <code>Cell</code>.</p>

<p>Now let&#39;s checkout <code>RefCell</code>&#39;s methods:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>RefCell</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>pub</span> <span class='kw'>const</span> <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>value</span>: <span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='ident'>RefCell</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> { <span class='comment'>/* ... */</span>}

    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>into_inner</span>(<span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>T</span> { <span class='comment'>/* ... */</span>}
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='question-mark'>?</span><span class='ident'>Sized</span><span class='op'>&gt;</span> <span class='ident'>RefCell</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>try_borrow</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>Ref</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>, <span class='ident'>BorrowError</span><span class='op'>&gt;</span> { <span class='comment'>/* ... */</span>}

    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>borrow</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>Ref</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> { <span class='comment'>/* ... */</span>}

    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>try_borrow_mut</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>RefMut</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>, <span class='ident'>BorrowMutError</span><span class='op'>&gt;</span> { <span class='comment'>/* ... */</span>}

    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>borrow_mut</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>RefMut</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> { <span class='comment'>/* ... */</span>}

    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>as_ptr</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>*</span><span class='kw-2'>mut</span> <span class='ident'>T</span> { <span class='comment'>/* ... */</span>}

    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>get_mut</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>T</span> { <span class='comment'>/* ... */</span>}
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%3CT%3E%20RefCell%3CT%3E%20%7B%0A%20%20%20%20pub%20const%20fn%20new(value%3A%20T)%20-%3E%20RefCell%3CT%3E%20%7B%20%2F*%20...%20*%2F%7D%0A%0A%20%20%20%20pub%20fn%20into_inner(self)%20-%3E%20T%20%7B%20%2F*%20...%20*%2F%7D%0A%7D%0A%0Aimpl%3CT%3A%20%3FSized%3E%20RefCell%3CT%3E%20%7B%0A%20%20%20%20pub%20fn%20try_borrow(%26self)%20-%3E%20Result%3CRef%3CT%3E%2C%20BorrowError%3E%20%7B%20%2F*%20...%20*%2F%7D%0A%0A%20%20%20%20pub%20fn%20borrow(%26self)%20-%3E%20Ref%3CT%3E%20%7B%20%2F*%20...%20*%2F%7D%0A%0A%20%20%20%20pub%20fn%20try_borrow_mut(%26self)%20-%3E%20Result%3CRefMut%3CT%3E%2C%20BorrowMutError%3E%20%7B%20%2F*%20...%20*%2F%7D%0A%0A%20%20%20%20pub%20fn%20borrow_mut(%26self)%20-%3E%20RefMut%3CT%3E%20%7B%20%2F*%20...%20*%2F%7D%0A%0A%20%20%20%20pub%20fn%20as_ptr(%26self)%20-%3E%20*mut%20T%20%7B%20%2F*%20...%20*%2F%7D%0A%0A%20%20%20%20pub%20fn%20get_mut(%26mut%20self)%20-%3E%20%26mut%20T%20%7B%20%2F*%20...%20*%2F%7D%0A%7D%0A%7D">Run</a></pre>

<p>As usual, <code>new</code> constructs a new <code>RefCell</code>, <code>into_inner</code> returns the celled value.</p>

<p><code>try_borrow</code> will try to immutably borrow the wrapped value. If the value is currently mutably borrowed, it would return an <code>Err</code>. If not, the value of the <code>borrow</code> flag would increment by 1, indicating that another immutable borrow has been made, then a custom reference type <code>Ref&lt;T&gt;</code> would be returned (inside an <code>Ok</code> of course). It has a <code>panic</code>ing variant, <code>borrow</code>.</p>

<p><code>try_borrow_mut</code> will try to mutably borrow the wrapped value. Note that it only requires a statically immutable <code>&amp;self</code>, such &quot;interior mutable&quot; semantics is, after all, what we&#39;ve been after. If the value is currently being borrowed (either mutably or not), it would return an <code>Err</code>. If not, then the value of the <code>borrow</code> flag would be set to <code>WRITING</code>, then a custom reference type <code>RefMut&lt;T&gt;</code> would be returned. It also has a <code>panic</code>ing variant <code>borrow_mut</code>.<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup></p>

<p>Now <code>BorrowError</code> and <code>BorrowMutError</code> are just some random error types with their formatting traits defined:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>BorrowError</span> {
    <span class='ident'>_private</span>: (),
}

<span class='kw'>impl</span> <span class='ident'>Debug</span> <span class='kw'>for</span> <span class='ident'>BorrowError</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>fmt</span>::<span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='ident'>fmt</span>::<span class='prelude-ty'>Result</span> {
        <span class='ident'>f</span>.<span class='ident'>debug_struct</span>(<span class='string'>&quot;BorrowError&quot;</span>).<span class='ident'>finish</span>()
    }
}

<span class='kw'>impl</span> <span class='ident'>Display</span> <span class='kw'>for</span> <span class='ident'>BorrowError</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>fmt</span>::<span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='ident'>fmt</span>::<span class='prelude-ty'>Result</span> {
        <span class='ident'>Display</span>::<span class='ident'>fmt</span>(<span class='string'>&quot;already mutably borrowed&quot;</span>, <span class='ident'>f</span>)
    }
}

<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>BorrowMutError</span> {
    <span class='ident'>_private</span>: (),
}

<span class='kw'>impl</span> <span class='ident'>Debug</span> <span class='kw'>for</span> <span class='ident'>BorrowMutError</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>fmt</span>::<span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='ident'>fmt</span>::<span class='prelude-ty'>Result</span> {
        <span class='ident'>f</span>.<span class='ident'>debug_struct</span>(<span class='string'>&quot;BorrowMutError&quot;</span>).<span class='ident'>finish</span>()
    }
}

<span class='kw'>impl</span> <span class='ident'>Display</span> <span class='kw'>for</span> <span class='ident'>BorrowMutError</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>fmt</span>::<span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='ident'>fmt</span>::<span class='prelude-ty'>Result</span> {
        <span class='ident'>Display</span>::<span class='ident'>fmt</span>(<span class='string'>&quot;already borrowed&quot;</span>, <span class='ident'>f</span>)
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20struct%20BorrowError%20%7B%0A%20%20%20%20_private%3A%20()%2C%0A%7D%0A%0Aimpl%20Debug%20for%20BorrowError%20%7B%0A%20%20%20%20fn%20fmt(%26self%2C%20f%3A%20%26mut%20fmt%3A%3AFormatter)%20-%3E%20fmt%3A%3AResult%20%7B%0A%20%20%20%20%20%20%20%20f.debug_struct(%22BorrowError%22).finish()%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%20Display%20for%20BorrowError%20%7B%0A%20%20%20%20fn%20fmt(%26self%2C%20f%3A%20%26mut%20fmt%3A%3AFormatter)%20-%3E%20fmt%3A%3AResult%20%7B%0A%20%20%20%20%20%20%20%20Display%3A%3Afmt(%22already%20mutably%20borrowed%22%2C%20f)%0A%20%20%20%20%7D%0A%7D%0A%0Apub%20struct%20BorrowMutError%20%7B%0A%20%20%20%20_private%3A%20()%2C%0A%7D%0A%0Aimpl%20Debug%20for%20BorrowMutError%20%7B%0A%20%20%20%20fn%20fmt(%26self%2C%20f%3A%20%26mut%20fmt%3A%3AFormatter)%20-%3E%20fmt%3A%3AResult%20%7B%0A%20%20%20%20%20%20%20%20f.debug_struct(%22BorrowMutError%22).finish()%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%20Display%20for%20BorrowMutError%20%7B%0A%20%20%20%20fn%20fmt(%26self%2C%20f%3A%20%26mut%20fmt%3A%3AFormatter)%20-%3E%20fmt%3A%3AResult%20%7B%0A%20%20%20%20%20%20%20%20Display%3A%3Afmt(%22already%20borrowed%22%2C%20f)%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>What really interests us should be the reference type <code>Ref</code> and <code>RefMut</code>.</p>

<p>Let&#39;s take a look at type <code>Ref</code> first.  As mentioned above, mutability should be checked dynamically. Thus, when any <code>Ref</code> goes out of scope, the referent&#39;s <code>borrow</code> field should be set back to the state before borrowing. That is, its value should decrement by <code>1</code>.</p>

<p>The action is done when <code>Ref</code> goes out of scope. In Rust that is to say, <code>Ref</code> should implements the <code>Drop</code> trait and the action should happen in the <code>drop</code> method. Also, being a reference means that the <code>Deref</code> trait should be implemented. Now let&#39;s check out what <code>Ref</code> really do:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Ref</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span>, <span class='ident'>T</span>: <span class='question-mark'>?</span><span class='ident'>Sized</span> <span class='op'>+</span> <span class='lifetime'>&#39;b</span><span class='op'>&gt;</span> {
    <span class='ident'>value</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;b</span> <span class='ident'>T</span>,
    <span class='ident'>borrow</span>: <span class='ident'>BorrowRef</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span><span class='op'>&gt;</span>,
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span>, <span class='ident'>T</span>: <span class='question-mark'>?</span><span class='ident'>Sized</span><span class='op'>&gt;</span> <span class='ident'>Deref</span> <span class='kw'>for</span> <span class='ident'>Ref</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>type</span> <span class='ident'>Target</span> <span class='op'>=</span> <span class='ident'>T</span>;

    <span class='attribute'>#[<span class='ident'>inline</span>]</span>
    <span class='kw'>fn</span> <span class='ident'>deref</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='ident'>T</span> {
        <span class='self'>self</span>.<span class='ident'>value</span>
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20struct%20Ref%3C'b%2C%20T%3A%20%3FSized%20%2B%20'b%3E%20%7B%0A%20%20%20%20value%3A%20%26'b%20T%2C%0A%20%20%20%20borrow%3A%20BorrowRef%3C'b%3E%2C%0A%7D%0A%0Aimpl%3C'b%2C%20T%3A%20%3FSized%3E%20Deref%20for%20Ref%3C'b%2C%20T%3E%20%7B%0A%20%20%20%20type%20Target%20%3D%20T%3B%0A%0A%20%20%20%20%23%5Binline%5D%0A%20%20%20%20fn%20deref(%26self)%20-%3E%20%26T%20%7B%0A%20%20%20%20%20%20%20%20self.value%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Obviously, the <code>value: &amp;&#39;b T</code> field should be the reference pointing to the referenced <code>RefCell&lt;T&gt;</code>&#39;s celled value. Also notice that it indeed implements the <code>Deref</code> trait (with the implementation exactly as we&#39;d expect). However, the <code>Drop</code> trait is nowhere to be seen. In fact, it makes use of another type, <code>BorrowRef&lt;&#39;b&gt;</code>, internally, which in turn implements <code>Drop</code>. Let&#39;s take a look at that type:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>BorrowRef</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span><span class='op'>&gt;</span> {
    <span class='ident'>borrow</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;b</span> <span class='ident'>Cell</span><span class='op'>&lt;</span><span class='ident'>BorrowFlag</span><span class='op'>&gt;</span>,
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span><span class='op'>&gt;</span> <span class='ident'>BorrowRef</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span><span class='op'>&gt;</span> {
    <span class='attribute'>#[<span class='ident'>inline</span>]</span>
    <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>borrow</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;b</span> <span class='ident'>Cell</span><span class='op'>&lt;</span><span class='ident'>BorrowFlag</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>BorrowRef</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span><span class='op'>&gt;&gt;</span> {
        <span class='kw'>match</span> <span class='ident'>borrow</span>.<span class='ident'>get</span>() {
            <span class='ident'>WRITING</span> <span class='op'>=&gt;</span> <span class='prelude-val'>None</span>,
            <span class='ident'>b</span> <span class='op'>=&gt;</span> {
                <span class='ident'>borrow</span>.<span class='ident'>set</span>(<span class='ident'>b</span> <span class='op'>+</span> <span class='number'>1</span>);
                <span class='prelude-val'>Some</span>(<span class='ident'>BorrowRef</span>{ <span class='ident'>borrow</span>: <span class='ident'>borrow</span> })
            },
        }
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span><span class='op'>&gt;</span> <span class='ident'>Drop</span> <span class='kw'>for</span> <span class='ident'>BorrowRef</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span><span class='op'>&gt;</span> {
    <span class='attribute'>#[<span class='ident'>inline</span>]</span>
    <span class='kw'>fn</span> <span class='ident'>drop</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) {
        <span class='kw'>let</span> <span class='ident'>borrow</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>borrow</span>.<span class='ident'>get</span>();
        <span class='macro'>debug_assert</span><span class='macro'>!</span>(<span class='ident'>borrow</span> <span class='op'>!=</span> <span class='ident'>WRITING</span> <span class='op'>&amp;&amp;</span> <span class='ident'>borrow</span> <span class='op'>!=</span> <span class='ident'>UNUSED</span>);
        <span class='self'>self</span>.<span class='ident'>borrow</span>.<span class='ident'>set</span>(<span class='ident'>borrow</span> <span class='op'>-</span> <span class='number'>1</span>);
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span><span class='op'>&gt;</span> <span class='ident'>Clone</span> <span class='kw'>for</span> <span class='ident'>BorrowRef</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span><span class='op'>&gt;</span> {
    <span class='attribute'>#[<span class='ident'>inline</span>]</span>
    <span class='kw'>fn</span> <span class='ident'>clone</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>BorrowRef</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span><span class='op'>&gt;</span> {
        <span class='kw'>let</span> <span class='ident'>borrow</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>borrow</span>.<span class='ident'>get</span>();
        <span class='macro'>debug_assert</span><span class='macro'>!</span>(<span class='ident'>borrow</span> <span class='op'>!=</span> <span class='ident'>UNUSED</span>);
        <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>borrow</span> <span class='op'>!=</span> <span class='ident'>WRITING</span>);
        <span class='self'>self</span>.<span class='ident'>borrow</span>.<span class='ident'>set</span>(<span class='ident'>borrow</span> <span class='op'>+</span> <span class='number'>1</span>);
        <span class='ident'>BorrowRef</span>{ <span class='ident'>borrow</span>: <span class='self'>self</span>.<span class='ident'>borrow</span> }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Astruct%20BorrowRef%3C'b%3E%20%7B%0A%20%20%20%20borrow%3A%20%26'b%20Cell%3CBorrowFlag%3E%2C%0A%7D%0A%0Aimpl%3C'b%3E%20BorrowRef%3C'b%3E%20%7B%0A%20%20%20%20%23%5Binline%5D%0A%20%20%20%20fn%20new(borrow%3A%20%26'b%20Cell%3CBorrowFlag%3E)%20-%3E%20Option%3CBorrowRef%3C'b%3E%3E%20%7B%0A%20%20%20%20%20%20%20%20match%20borrow.get()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20WRITING%20%3D%3E%20None%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20b%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20borrow.set(b%20%2B%201)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Some(BorrowRef%7B%20borrow%3A%20borrow%20%7D)%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%3C'b%3E%20Drop%20for%20BorrowRef%3C'b%3E%20%7B%0A%20%20%20%20%23%5Binline%5D%0A%20%20%20%20fn%20drop(%26mut%20self)%20%7B%0A%20%20%20%20%20%20%20%20let%20borrow%20%3D%20self.borrow.get()%3B%0A%20%20%20%20%20%20%20%20debug_assert!(borrow%20!%3D%20WRITING%20%26%26%20borrow%20!%3D%20UNUSED)%3B%0A%20%20%20%20%20%20%20%20self.borrow.set(borrow%20-%201)%3B%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%3C'b%3E%20Clone%20for%20BorrowRef%3C'b%3E%20%7B%0A%20%20%20%20%23%5Binline%5D%0A%20%20%20%20fn%20clone(%26self)%20-%3E%20BorrowRef%3C'b%3E%20%7B%0A%20%20%20%20%20%20%20%20let%20borrow%20%3D%20self.borrow.get()%3B%0A%20%20%20%20%20%20%20%20debug_assert!(borrow%20!%3D%20UNUSED)%3B%0A%20%20%20%20%20%20%20%20assert!(borrow%20!%3D%20WRITING)%3B%0A%20%20%20%20%20%20%20%20self.borrow.set(borrow%20%2B%201)%3B%0A%20%20%20%20%20%20%20%20BorrowRef%7B%20borrow%3A%20self.borrow%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>It turns out that this type is simply just a wrapper around a reference to a celled flag.</p>

<p>The associated <code>new</code> method is somewhat unusual as it returns an <code>Option</code> (instead of <code>Self</code> as what we&#39;d normally expect). internally, it determines if the flag presented is <code>WRITING</code>(indicating an immutable borrow is active). If it is, the method returns <code>None</code> indicating borrowing failure; it not, it returns a <code>Some</code> with the referenced flag count incremented (indicating another immutable borrow has been activated).</p>

<p>The <code>Drop</code> trait&#39;s <code>drop</code> method, on the contrary, decrements the referenced flag count, indicating that current immutable borrow has gone out of scope.</p>

<p>The <code>Clone</code> implementation by now should appears to be trivial.</p>

<p>This additional layer of abstraction allows the following method to be implemented:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span>, <span class='ident'>T</span>: <span class='question-mark'>?</span><span class='ident'>Sized</span><span class='op'>&gt;</span> <span class='ident'>Ref</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>map</span><span class='op'>&lt;</span><span class='ident'>U</span>: <span class='question-mark'>?</span><span class='ident'>Sized</span>, <span class='ident'>F</span><span class='op'>&gt;</span>(<span class='ident'>orig</span>: <span class='ident'>Ref</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span>, <span class='ident'>T</span><span class='op'>&gt;</span>, <span class='ident'>f</span>: <span class='ident'>F</span>) <span class='op'>-&gt;</span> <span class='ident'>Ref</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span>, <span class='ident'>U</span><span class='op'>&gt;</span>
        <span class='kw'>where</span> <span class='ident'>F</span>: <span class='ident'>FnOnce</span>(<span class='kw-2'>&amp;</span><span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='ident'>U</span> {
        <span class='ident'>Ref</span> {
            <span class='ident'>value</span>: <span class='ident'>f</span>(<span class='ident'>orig</span>.<span class='ident'>value</span>),
            <span class='ident'>borrow</span>: <span class='ident'>orig</span>.<span class='ident'>borrow</span>,
        }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%3C'b%2C%20T%3A%20%3FSized%3E%20Ref%3C'b%2C%20T%3E%20%7B%0A%20%20%20%20pub%20fn%20map%3CU%3A%20%3FSized%2C%20F%3E(orig%3A%20Ref%3C'b%2C%20T%3E%2C%20f%3A%20F)%20-%3E%20Ref%3C'b%2C%20U%3E%0A%20%20%20%20%20%20%20%20where%20F%3A%20FnOnce(%26T)%20-%3E%20%26U%20%7B%0A%20%20%20%20%20%20%20%20Ref%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20value%3A%20f(orig.value)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20borrow%3A%20orig.borrow%2C%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>The <code>map</code> function takes an <code>Ref&lt;&#39;b, T&gt;</code>, a function <code>FnOnce&lt;&amp;T) -&gt; &amp;U</code> and returns a <code>Ref&lt;&#39;b, U&gt;</code>. This function can be useful when we are only interested in some subfields of the originally referenced type. Take this example:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cell</span>::{<span class='ident'>RefCell</span>, <span class='ident'>Ref</span>};
<span class='kw'>let</span> <span class='ident'>c</span> <span class='op'>=</span> <span class='ident'>RefCell</span>::<span class='ident'>new</span>((<span class='number'>5</span>, <span class='string'>&#39;b&#39;</span>));
<span class='kw'>let</span> <span class='ident'>b1</span> <span class='op'>=</span> <span class='ident'>c</span>.<span class='ident'>borrow</span>(); <span class='comment'>// b1: Ref&lt;(i32, char)&gt;</span>
<span class='kw'>let</span> <span class='ident'>b2</span> <span class='op'>=</span> <span class='ident'>Ref</span>::<span class='ident'>map</span>(<span class='ident'>b1</span>, <span class='op'>|</span><span class='ident'>t</span><span class='op'>|</span> <span class='kw-2'>&amp;</span><span class='ident'>t</span>.<span class='number'>0</span>); <span class='comment'>// b2: Ref&lt;i32&gt;</span>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='kw-2'>*</span><span class='ident'>b2</span>, <span class='number'>5</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Ause%20std%3A%3Acell%3A%3A%7BRefCell%2C%20Ref%7D%3B%0Alet%20c%20%3D%20RefCell%3A%3Anew((5%2C%20'b'))%3B%0Alet%20b1%20%3D%20c.borrow()%3B%20%2F%2F%20b1%3A%20Ref%3C(i32%2C%20char)%3E%0Alet%20b2%20%3D%20Ref%3A%3Amap(b1%2C%20%7Ct%7C%20%26t.0)%3B%20%2F%2F%20b2%3A%20Ref%3Ci32%3E%0Aassert_eq!(*b2%2C%205)%3B%0A%7D">Run</a></pre>

<p>Separating the management of borrow checking out (into a <code>BorrowRef&lt;&#39;b&gt;</code>) from the reference type <code>Ref&lt;&#39;b, T&gt;</code> makes the implementation of such function trivial.</p>

<p>Notice that this is an associated function rather than a method, meaning that it can only be used as <code>Ref::map</code>. This is it so that when <code>Ref&lt;&#39;b, T&gt;</code> gets automatically dereferenced, the function&#39;s (commonly seen) name <code>map</code> wouldn&#39;t interfere with methods of the same name on the dereferenced <code>T</code> type.</p>

<p>Similarly, for mutable referencing there are <code>RefMut&lt;&#39;b, T&gt;</code> and <code>BorrowMutRef&lt;&#39;b&gt;</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>BorrowRefMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span><span class='op'>&gt;</span> {
    <span class='ident'>borrow</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;b</span> <span class='ident'>Cell</span><span class='op'>&lt;</span><span class='ident'>BorrowFlag</span><span class='op'>&gt;</span>,
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span><span class='op'>&gt;</span> <span class='ident'>Drop</span> <span class='kw'>for</span> <span class='ident'>BorrowRefMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span><span class='op'>&gt;</span> {
    <span class='attribute'>#[<span class='ident'>inline</span>]</span>
    <span class='kw'>fn</span> <span class='ident'>drop</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) {
        <span class='kw'>let</span> <span class='ident'>borrow</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>borrow</span>.<span class='ident'>get</span>();
        <span class='macro'>debug_assert</span><span class='macro'>!</span>(<span class='ident'>borrow</span> <span class='op'>==</span> <span class='ident'>WRITING</span>);
        <span class='self'>self</span>.<span class='ident'>borrow</span>.<span class='ident'>set</span>(<span class='ident'>UNUSED</span>);
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span><span class='op'>&gt;</span> <span class='ident'>BorrowRefMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span><span class='op'>&gt;</span> {
    <span class='attribute'>#[<span class='ident'>inline</span>]</span>
    <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>borrow</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;b</span> <span class='ident'>Cell</span><span class='op'>&lt;</span><span class='ident'>BorrowFlag</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>BorrowRefMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span><span class='op'>&gt;</span> {
        <span class='kw'>match</span> <span class='ident'>borrow</span>.<span class='ident'>get</span>() {
            <span class='ident'>UNUSED</span> <span class='op'>=&gt;</span> {
                <span class='ident'>borrow</span>.<span class='ident'>set</span>(<span class='ident'>WRITING</span>);
                <span class='prelude-val'>Some</span>(<span class='ident'>BorrowRefMut</span>{ <span class='ident'>borrow</span>: <span class='ident'>borrow</span>]})
            },
            _ <span class='op'>=&gt;</span> <span class='prelude-val'>None</span>,
        }
    }
}

<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>RefMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span>, <span class='ident'>T</span>: <span class='question-mark'>?</span><span class='ident'>Sized</span> <span class='op'>+</span> <span class='lifetime'>&#39;b</span><span class='op'>&gt;</span> {
    <span class='ident'>value</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;b</span> <span class='kw-2'>mut</span> <span class='ident'>T</span>,
    <span class='ident'>borrow</span>: <span class='ident'>BorrowRefMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span><span class='op'>&gt;</span>,
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span>, <span class='ident'>T</span>: <span class='question-mark'>?</span><span class='ident'>Sized</span><span class='op'>&gt;</span> <span class='ident'>Deref</span> <span class='kw'>for</span> <span class='ident'>RefMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>type</span> <span class='ident'>Target</span> <span class='op'>=</span> <span class='ident'>T</span>;

    <span class='attribute'>#[<span class='ident'>inline</span>]</span>
    <span class='kw'>fn</span> <span class='ident'>deref</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='ident'>T</span> {
        <span class='self'>self</span>.<span class='ident'>value</span>
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span>, <span class='ident'>T</span>: <span class='question-mark'>?</span><span class='ident'>Sized</span><span class='op'>&gt;</span> <span class='ident'>DerefMut</span> <span class='kw'>for</span> <span class='ident'>RefMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='attribute'>#[<span class='ident'>inline</span>]</span>
    <span class='kw'>fn</span> <span class='ident'>deref_mut</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>T</span> {
        <span class='self'>self</span>.<span class='ident'>value</span>
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span>, <span class='ident'>T</span>: <span class='question-mark'>?</span><span class='ident'>Sized</span><span class='op'>&gt;</span> <span class='ident'>RefMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>map</span><span class='op'>&lt;</span><span class='ident'>U</span>: <span class='question-mark'>?</span><span class='ident'>Sized</span>, <span class='ident'>F</span><span class='op'>&gt;</span>(<span class='ident'>orig</span>: <span class='ident'>RefMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span>, <span class='ident'>T</span><span class='op'>&gt;</span>, <span class='ident'>f</span>: <span class='ident'>F</span>)
        <span class='kw'>where</span> <span class='ident'>F</span>: <span class='ident'>FnOnce</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>U</span> {
        <span class='ident'>RefMut</span> {
            <span class='ident'>value</span>: <span class='ident'>f</span>(<span class='ident'>prig</span>.<span class='ident'>value</span>),
            <span class='ident'>borrow</span>: <span class='ident'>orig</span>.<span class='ident'>borrow</span>,
        }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Astruct%20BorrowRefMut%3C'b%3E%20%7B%0A%20%20%20%20borrow%3A%20%26'b%20Cell%3CBorrowFlag%3E%2C%0A%7D%0A%0Aimpl%3C'b%3E%20Drop%20for%20BorrowRefMut%3C'b%3E%20%7B%0A%20%20%20%20%23%5Binline%5D%0A%20%20%20%20fn%20drop(%26mut%20self)%20%7B%0A%20%20%20%20%20%20%20%20let%20borrow%20%3D%20self.borrow.get()%3B%0A%20%20%20%20%20%20%20%20debug_assert!(borrow%20%3D%3D%20WRITING)%3B%0A%20%20%20%20%20%20%20%20self.borrow.set(UNUSED)%3B%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%3C'b%3E%20BorrowRefMut%3C'b%3E%20%7B%0A%20%20%20%20%23%5Binline%5D%0A%20%20%20%20fn%20new(borrow%3A%20%26'b%20Cell%3CBorrowFlag%3E)%20-%3E%20Option%3CBorrowRefMut%3C'b%3E%20%7B%0A%20%20%20%20%20%20%20%20match%20borrow.get()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20UNUSED%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20borrow.set(WRITING)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Some(BorrowRefMut%7B%20borrow%3A%20borrow%5D%7D)%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20_%20%3D%3E%20None%2C%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%0Apub%20struct%20RefMut%3C'b%2C%20T%3A%20%3FSized%20%2B%20'b%3E%20%7B%0A%20%20%20%20value%3A%20%26'b%20mut%20T%2C%0A%20%20%20%20borrow%3A%20BorrowRefMut%3C'b%3E%2C%0A%7D%0A%0Aimpl%3C'b%2C%20T%3A%20%3FSized%3E%20Deref%20for%20RefMut%3C'b%2C%20T%3E%20%7B%0A%20%20%20%20type%20Target%20%3D%20T%3B%0A%0A%20%20%20%20%23%5Binline%5D%0A%20%20%20%20fn%20deref(%26self)%20-%3E%20%26T%20%7B%0A%20%20%20%20%20%20%20%20self.value%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%3C'b%2C%20T%3A%20%3FSized%3E%20DerefMut%20for%20RefMut%3C'b%2C%20T%3E%20%7B%0A%20%20%20%20%23%5Binline%5D%0A%20%20%20%20fn%20deref_mut(%26mut%20self)%20-%3E%20%26mut%20T%20%7B%0A%20%20%20%20%20%20%20%20self.value%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%3C'b%2C%20T%3A%20%3FSized%3E%20RefMut%3C'b%2C%20T%3E%20%7B%0A%20%20%20%20pub%20fn%20map%3CU%3A%20%3FSized%2C%20F%3E(orig%3A%20RefMut%3C'b%2C%20T%3E%2C%20f%3A%20F)%0A%20%20%20%20%20%20%20%20where%20F%3A%20FnOnce(%26mut%20T)%20-%3E%20%26mut%20U%20%7B%0A%20%20%20%20%20%20%20%20RefMut%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20value%3A%20f(prig.value)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20borrow%3A%20orig.borrow%2C%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>With these structures introduced, now we can finally check out how the methods of <code>RefCell&lt;T&gt;</code> are implemented:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>RefCell</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='attribute'>#[<span class='ident'>inline</span>]</span>
    <span class='kw'>pub</span> <span class='kw'>const</span> <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>value</span>: <span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='ident'>RefCell</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
        <span class='ident'>RefCell</span> {
            <span class='ident'>value</span>: <span class='ident'>UnsafeCell</span>::<span class='ident'>new</span>(<span class='ident'>value</span>),
            <span class='ident'>borrow</span>: <span class='ident'>Cell</span>::<span class='ident'>new</span>(<span class='ident'>UNUSED</span>),
        }
    }

    <span class='attribute'>#[<span class='ident'>inline</span>]</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>into_inner</span>(<span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>T</span> {
        <span class='macro'>debug_assert</span><span class='macro'>!</span>(<span class='self'>self</span>.<span class='ident'>borrow</span>.<span class='ident'>get</span>() <span class='op'>==</span> <span class='ident'>UNUSED</span>);
        <span class='kw'>unsafe</span> { <span class='self'>self</span>.<span class='ident'>value</span>.<span class='ident'>into_inner</span>() }
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='question-mark'>?</span><span class='ident'>Sized</span><span class='op'>&gt;</span> <span class='ident'>RefCell</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='attribute'>#[<span class='ident'>inline</span>]</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>try_borrow</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>Ref</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>, <span class='ident'>BorrowError</span><span class='op'>&gt;</span> {
        <span class='kw'>match</span> <span class='ident'>BorrowRef</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>.<span class='ident'>borrow</span>) {
            <span class='prelude-val'>Some</span>(<span class='ident'>b</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Ok</span>(<span class='ident'>Ref</span> {
                <span class='ident'>value</span>: <span class='kw'>unsafe</span> { <span class='kw-2'>&amp;</span><span class='kw-2'>*</span><span class='self'>self</span>.<span class='ident'>value</span>.<span class='ident'>get</span>() },
                <span class='ident'>borrow</span>: <span class='ident'>b</span>,
            }),
            <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='prelude-val'>Err</span>(<span class='ident'>BorrowError</span> {<span class='ident'>_private</span>: () }),
        }
    }

    <span class='attribute'>#[<span class='ident'>inline</span>]</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>borrow</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>Ref</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
        <span class='self'>self</span>.<span class='ident'>try_borrow</span>().<span class='ident'>expect</span>(<span class='string'>&quot;already mutably borrowed&quot;</span>)
    }

    <span class='attribute'>#[<span class='ident'>inline</span>]</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>try_borrow_mut</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>RefMut</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>, <span class='ident'>BorrowMutError</span><span class='op'>&gt;</span> {
        <span class='kw'>match</span> <span class='ident'>BorrowRefMut</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>.<span class='ident'>borrow</span>) {
            <span class='prelude-val'>Some</span>(<span class='ident'>b</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Ok</span>(<span class='ident'>RefMut</span> {
                <span class='ident'>value</span>: <span class='kw'>unsafe</span> { <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='kw-2'>*</span><span class='self'>self</span>.<span class='ident'>value</span>.<span class='ident'>get</span>() },
                <span class='ident'>borrow</span>: <span class='ident'>b</span>,
            }),
            <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='prelude-val'>Err</span>(<span class='ident'>BorrowMutError</span> { <span class='ident'>_private</span>: () } ),
        }
    }

    <span class='attribute'>#[<span class='ident'>inline</span>]</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>borrow_mut</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>RefMut</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
        <span class='self'>self</span>.<span class='ident'>try_borrow_mut</span>().<span class='ident'>expect</span>(<span class='string'>&quot;already borrowed&quot;</span>)
    }

    <span class='attribute'>#[<span class='ident'>inline</span>]</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>as_ptr</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>*</span><span class='kw-2'>mut</span> <span class='ident'>T</span> {
        <span class='self'>self</span>.<span class='ident'>value</span>.<span class='ident'>get</span>()
    }

    <span class='attribute'>#[<span class='ident'>inline</span>]</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>get_mut</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>T</span> {
        <span class='kw'>unsafe</span> { <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='kw-2'>*</span><span class='self'>self</span>.<span class='ident'>value</span>.<span class='ident'>get</span>() }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%3CT%3E%20RefCell%3CT%3E%20%7B%0A%20%20%20%20%23%5Binline%5D%0A%20%20%20%20pub%20const%20fn%20new(value%3A%20T)%20-%3E%20RefCell%3CT%3E%20%7B%0A%20%20%20%20%20%20%20%20RefCell%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20value%3A%20UnsafeCell%3A%3Anew(value)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20borrow%3A%20Cell%3A%3Anew(UNUSED)%2C%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20%23%5Binline%5D%0A%20%20%20%20pub%20fn%20into_inner(self)%20-%3E%20T%20%7B%0A%20%20%20%20%20%20%20%20debug_assert!(self.borrow.get()%20%3D%3D%20UNUSED)%3B%0A%20%20%20%20%20%20%20%20unsafe%20%7B%20self.value.into_inner()%20%7D%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%3CT%3A%20%3FSized%3E%20RefCell%3CT%3E%20%7B%0A%20%20%20%20%23%5Binline%5D%0A%20%20%20%20pub%20fn%20try_borrow(%26self)%20-%3E%20Result%3CRef%3CT%3E%2C%20BorrowError%3E%20%7B%0A%20%20%20%20%20%20%20%20match%20BorrowRef%3A%3Anew(%26self.borrow)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20Some(b)%20%3D%3E%20Ok(Ref%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20value%3A%20unsafe%20%7B%20%26*self.value.get()%20%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20borrow%3A%20b%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20None%20%3D%3E%20Err(BorrowError%20%7B_private%3A%20()%20%7D)%2C%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20%23%5Binline%5D%0A%20%20%20%20pub%20fn%20borrow(%26self)%20-%3E%20Ref%3CT%3E%20%7B%0A%20%20%20%20%20%20%20%20self.try_borrow().expect(%22already%20mutably%20borrowed%22)%0A%20%20%20%20%7D%0A%0A%20%20%20%20%23%5Binline%5D%0A%20%20%20%20pub%20fn%20try_borrow_mut(%26self)%20-%3E%20Result%3CRefMut%3CT%3E%2C%20BorrowMutError%3E%20%7B%0A%20%20%20%20%20%20%20%20match%20BorrowRefMut%3A%3Anew(%26self.borrow)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20Some(b)%20%3D%3E%20Ok(RefMut%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20value%3A%20unsafe%20%7B%20%26mut%20*self.value.get()%20%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20borrow%3A%20b%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20None%20%3D%3E%20Err(BorrowMutError%20%7B%20_private%3A%20()%20%7D%20)%2C%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20%23%5Binline%5D%0A%20%20%20%20pub%20fn%20borrow_mut(%26self)%20-%3E%20RefMut%3CT%3E%20%7B%0A%20%20%20%20%20%20%20%20self.try_borrow_mut().expect(%22already%20borrowed%22)%0A%20%20%20%20%7D%0A%0A%20%20%20%20%23%5Binline%5D%0A%20%20%20%20pub%20fn%20as_ptr(%26self)%20-%3E%20*mut%20T%20%7B%0A%20%20%20%20%20%20%20%20self.value.get()%0A%20%20%20%20%7D%0A%0A%20%20%20%20%23%5Binline%5D%0A%20%20%20%20pub%20fn%20get_mut(%26mut%20self)%20-%3E%20%26mut%20T%20%7B%0A%20%20%20%20%20%20%20%20unsafe%20%7B%20%26mut%20*self.value.get()%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Simple and clear.</p>

<p>Like <code>UnsafeCell&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code> implements <code>From&lt;T&gt;</code> and <code>!Sync</code>. It also implements <code>Send</code>, <code>Clone</code>, <code>Default</code>, <code>Debug</code>, <code>Eq</code>, <code>Ord</code>, <code>PartialEq&lt;RefCell&lt;T&gt;&gt;</code>, <code>PartialOrd&lt;RefCell&lt;T&gt;&gt;</code> when <code>T</code> implements those traits, respectively.<sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup></p>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>Actually <code>RefCell</code> has yet another method <code>borrow_state</code>. We didn&#39;t cover it in the text because it is unstable currently, and it won&#39;t be stable in any foreseeable future, as discussed in its related <a href="https://github.com/rust-lang/rust/issues/27733">issue</a>. The discussion itself, however, is worth mentioning, because it explained some general philosophy behind the interface designing of the standard library. Anyone interested should take a look.&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

<li id="fn2">
<p>As <a href="https://github.com/rust-lang/rfcs/pull/1651">RFC 1651</a> points out, the API design of <code>Cell</code> can be altered to support non-<code>Copy</code> types, check it out for more details. The actual implementation is nowhere under its way into the standard library yet, thus we wouldn&#39;t cover it here.&nbsp;<a href="#fnref2" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

    <script src='rustbook.js'></script>
</div></div>


</body>
</html>