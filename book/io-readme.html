<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>std::io</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ol class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='macros-readme.html'><b>2.</b> Macros in std</a>
</li>
<li><a  href='mods-readme.html'><b>3.</b> Uncategorized Modules</a>
<ol class='section'>
<li><a  href='any-readme.html'><b>3.1.</b> std::any</a>
</li>
<li><a  href='ascii-readme.html'><b>3.2.</b> std::ascii</a>
</li>
<li><a  href='borrow-readme.html'><b>3.3.</b> std::borrow</a>
</li>
<li><a  href='boxed-readme.html'><b>3.4.</b> std::boxed</a>
</li>
<li><a  href='cell-readme.html'><b>3.5.</b> std::cell</a>
</li>
<li><a  href='clone-readme.html'><b>3.6.</b> std::clone</a>
</li>
<li><a  href='cmp-readme.html'><b>3.7.</b> std::cmp</a>
</li>
<li><a  href='collections-readme.html'><b>3.8.</b> std::collections</a>
</li>
<li><a  href='convert-readme.html'><b>3.9.</b> std::convert</a>
</li>
<li><a  href='default-readme.html'><b>3.10.</b> std::default</a>
</li>
<li><a  href='env-readme.html'><b>3.11.</b> std::env</a>
</li>
<li><a  href='error-readme.html'><b>3.12.</b> std::error</a>
</li>
<li><a  href='ffi-readme.html'><b>3.13.</b> std::ffi</a>
</li>
<li><a  href='fmt-readme.html'><b>3.14.</b> std::fmt</a>
</li>
<li><a  href='fs-readme.html'><b>3.15.</b> std::fs</a>
</li>
<li><a  href='hash-readme.html'><b>3.16.</b> std::hash</a>
</li>
<li><a class='active' href='io-readme.html'><b>3.17.</b> std::io</a>
</li>
</ol>
</li>
</ol>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">std::io</h1>
    <blockquote>
<p><a href="https://doc.rust-lang.org/std/io/">https://doc.rust-lang.org/std/io/</a></p>
</blockquote>

<p>This module provides general support for IO.</p>

<h1 id='io-traits' class='section-header'><a href='#io-traits'>IO Traits</a></h1>
<p>At the very core, the module defines some traits representing objects that are capable of doing IO.</p>

<h2 id='read' class='section-header'><a href='#read'>Read</a></h2>
<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Read</span> {
    <span class='kw'>fn</span> <span class='ident'>read</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>buf</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='ident'>u8</span>]) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span>;
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20trait%20Read%20%7B%0A%20%20%20%20fn%20read(%26mut%20self%2C%20buf%3A%20%26mut%20%5Bu8%5D)%20-%3E%20Result%3Cusize%3E%3B%0A%7D%0A%7D">Run</a></pre>

<p>The <code>Read</code> trait represents a <code>Reader</code>, from which one can read data. It&#39;s sole required method, <code>reader.read(dst)</code>, attempts to pull bytes from <code>reader</code> into <code>dst</code>. The returned value represents how many bytes are actually read (on success). The function might block (or not). If the returned value is <code>Ok(n)</code>, then <code>0 &lt;= n &lt;= buf.len()</code> must hold. <code>n == 0</code> means either <code>EOF</code> has been reached or the buffer specified was zero length.</p>

<p>The returned <code>Result</code> is actually defined as:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>type</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>Error</span><span class='op'>&gt;</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atype%20Result%3CT%3E%20%3D%20Result%3CT%2C%20Error%3E%3B%0A%7D">Run</a></pre>

<p>We&#39;d come to this <code>Error</code> type later.</p>

<p>With the <code>read</code> method implemented, <code>Read</code> also provides some additional defaultly implemented methods, including:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Read</span> {
    <span class='kw'>fn</span> <span class='ident'>read_to_end</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>buf</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span> {
        <span class='ident'>read_to_end</span>(<span class='self'>self</span>, <span class='ident'>buf</span>)
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20trait%20Read%20%7B%0A%20%20%20%20fn%20read_to_end(%26mut%20self%2C%20buf%3A%20%26mut%20Vec%3Cu8%3E)%20-%3E%20Result%3Cusize%3E%20%7B%0A%20%20%20%20%20%20%20%20read_to_end(self%2C%20buf)%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>The method would try to read all bytes into the provided <code>Vec</code> until <code>EOF</code> is reached. All bytes read will be appended into the <code>buf</code>. Internally, it calls the module-wide implementation function <code>read_to_end</code>, which is defined as:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>DEFAULT_BUF_SIZE</span>: <span class='ident'>usize</span> <span class='op'>=</span> ::<span class='ident'>sys_common</span>::<span class='ident'>io</span>::<span class='ident'>DEFAULT_BUF_SIZE</span>;
<span class='kw'>fn</span> <span class='ident'>read_to_end</span><span class='op'>&lt;</span><span class='ident'>R</span><span class='op'>&gt;</span>(<span class='ident'>r</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>R</span>, <span class='ident'>buf</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span>
    <span class='kw'>where</span> <span class='ident'>R</span>: <span class='ident'>Read</span> <span class='op'>+</span> <span class='question-mark'>?</span><span class='ident'>Sized</span> {
    <span class='kw'>let</span> <span class='ident'>start_len</span> <span class='op'>=</span> <span class='ident'>buf</span>.<span class='ident'>len</span>();
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>len</span> <span class='op'>=</span> <span class='ident'>start_len</span>;
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>new_write_size</span> <span class='op'>=</span> <span class='number'>16</span>;
    <span class='kw'>let</span> <span class='ident'>ret</span>;
    <span class='kw'>loop</span> {
        <span class='kw'>if</span> <span class='ident'>len</span> <span class='op'>==</span> <span class='ident'>buf</span>.<span class='ident'>len</span>() {
            <span class='kw'>if</span> <span class='ident'>new_write_size</span> <span class='op'>&lt;</span> <span class='ident'>DEFAULT_BUF_SIZE</span> {
                <span class='ident'>new_write_size</span> <span class='op'>*=</span> <span class='number'>2</span>;
            }
            <span class='ident'>buf</span>.<span class='ident'>resize</span>(<span class='ident'>len</span> <span class='op'>+</span> <span class='ident'>new_write_size</span>, <span class='number'>0</span>);
        }

        <span class='kw'>match</span> <span class='ident'>r</span>.<span class='ident'>read</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>buf</span>[<span class='ident'>len</span>..]) {
            <span class='prelude-val'>Ok</span>(<span class='number'>0</span>) <span class='op'>=&gt;</span> {
                <span class='ident'>ret</span> <span class='op'>=</span> <span class='prelude-val'>Ok</span>(<span class='ident'>len</span> <span class='op'>-</span> <span class='ident'>start_len</span>);
                <span class='kw'>break</span>;
            }
            <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> <span class='ident'>len</span> <span class='op'>+=</span> <span class='ident'>n</span>,
            <span class='prelude-val'>Err</span>(<span class='kw-2'>ref</span> <span class='ident'>e</span>) <span class='kw'>if</span> <span class='ident'>e</span>.<span class='ident'>kind</span>() <span class='op'>==</span> <span class='ident'>ErrorKind</span>::<span class='ident'>interrupted</span> <span class='op'>=&gt;</span> {}
            <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> {
                <span class='ident'>ret</span> <span class='op'>=</span> <span class='prelude-val'>Err</span>(<span class='ident'>e</span>);
                <span class='kw'>break</span>;
            }
        }
    }
    <span class='ident'>buf</span>.<span class='ident'>truncate</span>(<span class='ident'>len</span>);
    <span class='ident'>ret</span>
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aconst%20DEFAULT_BUF_SIZE%3A%20usize%20%3D%20%3A%3Asys_common%3A%3Aio%3A%3ADEFAULT_BUF_SIZE%3B%0Afn%20read_to_end%3CR%3E(r%3A%20%26mut%20R%2C%20buf%3A%20%26mut%20Vec%3Cu8%3E)%20-%3E%20Result%3Cusize%3E%0A%20%20%20%20where%20R%3A%20Read%20%2B%20%3FSized%20%7B%0A%20%20%20%20let%20start_len%20%3D%20buf.len()%3B%0A%20%20%20%20let%20mut%20len%20%3D%20start_len%3B%0A%20%20%20%20let%20mut%20new_write_size%20%3D%2016%3B%0A%20%20%20%20let%20ret%3B%0A%20%20%20%20loop%20%7B%0A%20%20%20%20%20%20%20%20if%20len%20%3D%3D%20buf.len()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20new_write_size%20%3C%20DEFAULT_BUF_SIZE%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20new_write_size%20*%3D%202%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20buf.resize(len%20%2B%20new_write_size%2C%200)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20%20%20match%20r.read(%26mut%20buf%5Blen..%5D)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20Ok(0)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20ret%20%3D%20Ok(len%20-%20start_len)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20break%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20Ok(n)%20%3D%3E%20len%20%2B%3D%20n%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20Err(ref%20e)%20if%20e.kind()%20%3D%3D%20ErrorKind%3A%3Ainterrupted%20%3D%3E%20%7B%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20Err(e)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20ret%20%3D%20Err(e)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20break%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20buf.truncate(len)%3B%0A%20%20%20%20ret%0A%7D%0A%7D">Run</a></pre>

<p>The function uses a loop to repeatly read bytes from reader <code>r</code>, until an EOF is reached (indicated by an <code>Ok(0)</code>) or an error other than interruption is encountered. At the beginning of each loop, it checks whether the <code>buf</code>fer can read in any more bytes. If not, it allocates more capacity for the buffer. The allocation is done adaptivly, such that upon each new allocation, the additional size to be allocated would double. This reduces the total number of allocations needed. After the loop, the buffer is then truncated to the actual length of bytes it currently holds, and the result <code>ret</code> is returned.</p>

<p>There is also a method to read the bytes into a <code>&amp;mut String</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Read</span> {
    <span class='kw'>fn</span> <span class='ident'>read_to_string</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>buf</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>String</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span> {
        <span class='ident'>append_to_string</span>(<span class='ident'>buf</span>, <span class='op'>|</span><span class='ident'>b</span><span class='op'>|</span> <span class='ident'>read_to_end</span>(<span class='self'>self</span>, <span class='ident'>b</span>))
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20trait%20Read%20%7B%0A%20%20%20%20fn%20read_to_string(%26mut%20self%2C%20buf%3A%20%26mut%20String)%20-%3E%20Result%3Cusize%3E%20%7B%0A%20%20%20%20%20%20%20%20append_to_string(buf%2C%20%7Cb%7C%20read_to_end(self%2C%20b))%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Internally, it makes use of another implementation function:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>append_to_string</span><span class='op'>&lt;</span><span class='ident'>F</span><span class='op'>&gt;</span>(<span class='ident'>buf</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>String</span>, <span class='ident'>f</span>: <span class='ident'>F</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span>
    <span class='kw'>where</span> <span class='ident'>F</span>: <span class='ident'>FnOnce</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span> {
    <span class='kw'>struct</span> <span class='ident'>Guard</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> { <span class='ident'>s</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;</span>, <span class='ident'>len</span>: <span class='ident'>usize</span>, }
    <span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> <span class='ident'>Drop</span> <span class='kw'>for</span> <span class='ident'>Guard</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
        <span class='kw'>fn</span> <span class='ident'>drop</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) {
            <span class='kw'>unsafe</span> { <span class='self'>self</span>.<span class='ident'>s</span>.<span class='ident'>set_len</span>(<span class='self'>self</span>.<span class='ident'>len</span>); }
        }
    }

    <span class='kw'>unsafe</span> {
        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>g</span> <span class='op'>=</span> <span class='ident'>Guard</span> { <span class='ident'>len</span>: <span class='ident'>buf</span>.<span class='ident'>len</span>(), <span class='ident'>s</span>: <span class='ident'>buf</span>.<span class='ident'>as_mut_vec</span>() };
        <span class='kw'>let</span> <span class='ident'>ret</span> <span class='op'>=</span> <span class='ident'>f</span>(<span class='ident'>g</span>.<span class='ident'>s</span>);
        <span class='kw'>if</span> <span class='ident'>str</span>::<span class='ident'>from_utf8</span>(<span class='kw-2'>&amp;</span><span class='ident'>g</span>.<span class='ident'>s</span>[<span class='ident'>g</span>.<span class='ident'>len</span>..]).<span class='ident'>is_err</span>() {
            <span class='ident'>ret</span>.<span class='ident'>and_then</span>(<span class='op'>|</span>_<span class='op'>|</span> {
                <span class='prelude-val'>Err</span>(<span class='ident'>Error</span>::<span class='ident'>new</span>(<span class='ident'>ErrorKind</span>::<span class='ident'>InvalidData</span>,
                    <span class='string'>&quot;stream did not contain valid UTF-8&quot;</span>))
            })
        } <span class='kw'>else</span> {
            <span class='ident'>g</span>.<span class='ident'>len</span> <span class='op'>=</span> <span class='ident'>g</span>.<span class='ident'>s</span>.<span class='ident'>len</span>();
            <span class='ident'>ret</span>
        }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20append_to_string%3CF%3E(buf%3A%20%26mut%20String%2C%20f%3A%20F)%20-%3E%20Result%3Cusize%3E%0A%20%20%20%20where%20F%3A%20FnOnce(%26mut%20Vec%3Cu8%3E)%20-%3E%20Result%3Cusize%3E%20%7B%0A%20%20%20%20struct%20Guard%3C'a%3E%20%7B%20s%3A%20%26'a%20mut%20Vec%3Cu8%3E%2C%20len%3A%20usize%2C%20%7D%0A%20%20%20%20impl%3C'a%3E%20Drop%20for%20Guard%3C'a%3E%20%7B%0A%20%20%20%20%20%20%20%20fn%20drop(%26mut%20self)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20unsafe%20%7B%20self.s.set_len(self.len)%3B%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20let%20mut%20g%20%3D%20Guard%20%7B%20len%3A%20buf.len()%2C%20s%3A%20buf.as_mut_vec()%20%7D%3B%0A%20%20%20%20%20%20%20%20let%20ret%20%3D%20f(g.s)%3B%0A%20%20%20%20%20%20%20%20if%20str%3A%3Afrom_utf8(%26g.s%5Bg.len..%5D).is_err()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20ret.and_then(%7C_%7C%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Err(Error%3A%3Anew(ErrorKind%3A%3AInvalidData%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22stream%20did%20not%20contain%20valid%20UTF-8%22))%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D)%0A%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20g.len%20%3D%20g.s.len()%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20ret%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p><code>read_to_string</code> forwards the string buffer and a closure <code>|b| read_to_end(self, b)</code> to <code>append_to_string</code>. Inside <code>append_to_string</code>, the <code>String</code> is interpreted as a <code>&amp;mut Vec[u8]</code> and was passed to the closure. After the actual reading has complete within the closure, the function invokes <code>str::from_utf8</code> to check whether the additionally read bytes form valid <code>utf-8</code>, and returns an error if not. Otherwise, the resultant buffer is returned. The method utilizes a <code>Guard</code> struct to ensure that the additionally read bytes would be properly dropped if they are not valid UTF8.</p>

<p>Implemented this way with <code>unsafe</code>, the function ensures that no redundant memory-allocation or UTF8 checking is needed.</p>

<p>Next there is a method to read for exact bytes that the provided buffer can hold:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Read</span> {
    <span class='kw'>fn</span> <span class='ident'>read_exact</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='kw-2'>mut</span> <span class='ident'>buf</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='ident'>u8</span>]) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span> {
        <span class='kw'>while</span> <span class='op'>!</span><span class='ident'>buf</span>.<span class='ident'>is_empty</span>() {
            <span class='kw'>match</span> <span class='self'>self</span>.<span class='ident'>read</span>(<span class='ident'>buf</span>) {
                <span class='prelude-val'>Ok</span>(<span class='number'>0</span>) <span class='op'>=&gt;</span> <span class='kw'>break</span>,
                <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> { <span class='kw'>let</span> <span class='ident'>tmp</span> <span class='op'>=</span> <span class='ident'>buf</span>; <span class='ident'>buf</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>tmp</span>[<span class='ident'>n</span>..]; }
                <span class='prelude-val'>Err</span>(<span class='kw-2'>ref</span> <span class='ident'>e</span>) <span class='kw'>if</span> <span class='ident'>e</span>.<span class='ident'>kind</span>() <span class='op'>==</span> <span class='ident'>ErrorKind</span>::<span class='ident'>interrupted</span> <span class='op'>=&gt;</span> {}
                <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> <span class='kw'>return</span> <span class='prelude-val'>Err</span>(<span class='ident'>e</span>),
            }
        }

        <span class='kw'>if</span> <span class='op'>!</span><span class='ident'>buf</span>.<span class='ident'>is_empty</span>() {
            <span class='prelude-val'>Err</span>(<span class='ident'>Error</span>::<span class='ident'>new</span>(<span class='ident'>ErrorKind</span>::<span class='ident'>UnexpectedEof</span>,
                <span class='string'>&quot;failed to fill whole buffer&quot;</span>))
        } <span class='kw'>else</span> {
            <span class='prelude-val'>Ok</span>(())
        }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20trait%20Read%20%7B%0A%20%20%20%20fn%20read_exact(%26mut%20self%2C%20mut%20buf%3A%20%26mut%20%5Bu8%5D)%20-%3E%20Result%3C()%3E%20%7B%0A%20%20%20%20%20%20%20%20while%20!buf.is_empty()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20match%20self.read(buf)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Ok(0)%20%3D%3E%20break%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Ok(n)%20%3D%3E%20%7B%20let%20tmp%20%3D%20buf%3B%20buf%20%3D%20%26mut%20tmp%5Bn..%5D%3B%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Err(ref%20e)%20if%20e.kind()%20%3D%3D%20ErrorKind%3A%3Ainterrupted%20%3D%3E%20%7B%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Err(e)%20%3D%3E%20return%20Err(e)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20%20%20if%20!buf.is_empty()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20Err(Error%3A%3Anew(ErrorKind%3A%3AUnexpectedEof%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22failed%20to%20fill%20whole%20buffer%22))%0A%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20Ok(())%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>The implementation is quite straightforward. It makes use of a mutable reference, <code>buf</code>. When additional bytes is read into the buffer, <code>buf</code> shrinks. If the length of <code>buf</code> shrinks to <code>0</code>, then exact bytes of the original buffer size have been read. Early end of looping causd by errors causes early returns. Early end of looping caused by <code>EOF</code> is catched by another round of checking.</p>

<p>Next there is a utility method to create a mutable reference of this reader:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Read</span> {
    <span class='kw'>fn</span> <span class='ident'>by_ref</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>Self</span> <span class='kw'>where</span> <span class='self'>Self</span>: <span class='ident'>Sized</span> { <span class='self'>self</span> }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20trait%20Read%20%7B%0A%20%20%20%20fn%20by_ref(%26mut%20self)%20-%3E%20%26mut%20Self%20where%20Self%3A%20Sized%20%7B%20self%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Next there is a method to transform the reader into an <code>Iterator</code> over bytes:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Read</span> {
    <span class='kw'>fn</span> <span class='ident'>bytes</span>(<span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>Bytes</span><span class='op'>&lt;</span><span class='self'>Self</span><span class='op'>&gt;</span> <span class='kw'>where</span> <span class='self'>Self</span>: <span class='ident'>Sized</span> {
        <span class='ident'>Bytes</span> { <span class='ident'>inner</span>: <span class='self'>self</span> }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20trait%20Read%20%7B%0A%20%20%20%20fn%20bytes(self)%20-%3E%20Bytes%3CSelf%3E%20where%20Self%3A%20Sized%20%7B%0A%20%20%20%20%20%20%20%20Bytes%20%7B%20inner%3A%20self%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>The definition of the returned iterator is quite straightforward:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Bytes</span><span class='op'>&lt;</span><span class='ident'>R</span><span class='op'>&gt;</span> { <span class='ident'>inner</span>: <span class='ident'>R</span>, }

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>R</span>: <span class='ident'>Read</span><span class='op'>&gt;</span> <span class='ident'>Iterator</span> <span class='kw'>for</span> <span class='ident'>Bytes</span><span class='op'>&lt;</span><span class='ident'>R</span><span class='op'>&gt;</span> {
    <span class='kw'>type</span> <span class='ident'>Item</span> <span class='op'>=</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;</span>;
    <span class='kw'>fn</span> <span class='ident'>next</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;&gt;</span> {
        <span class='ident'>read_one_byte</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>.<span class='ident'>inner</span>)
    }
}

<span class='comment'>// utility method</span>
<span class='kw'>fn</span> <span class='ident'>read_one_byte</span>(<span class='ident'>reader</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Read</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>buf</span> <span class='op'>=</span> [<span class='number'>0</span>];
    <span class='kw'>loop</span> {
        <span class='kw'>return</span> <span class='kw'>match</span> <span class='ident'>reader</span>.<span class='ident'>read</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>buf</span>) {
            <span class='prelude-val'>Ok</span>(<span class='number'>0</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>None</span>,
            <span class='prelude-val'>Ok</span>(..) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='prelude-val'>Ok</span>(<span class='ident'>buf</span>[<span class='number'>0</span>])),
            <span class='prelude-val'>Err</span>(<span class='kw-2'>ref</span> <span class='ident'>e</span>) <span class='kw'>if</span> <span class='ident'>e</span>.<span class='ident'>kind</span>() <span class='op'>==</span> <span class='ident'>ErrorKind</span>::<span class='ident'>interrupted</span> <span class='op'>=&gt;</span> <span class='kw'>continue</span>,
            <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='prelude-val'>Err</span>(<span class='ident'>e</span>)),
        }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20struct%20Bytes%3CR%3E%20%7B%20inner%3A%20R%2C%20%7D%0A%0Aimpl%3CR%3A%20Read%3E%20Iterator%20for%20Bytes%3CR%3E%20%7B%0A%20%20%20%20type%20Item%20%3D%20Result%3Cu8%3E%3B%0A%20%20%20%20fn%20next(%26mut%20self)%20-%3E%20Option%3CResult%3Cu8%3E%3E%20%7B%0A%20%20%20%20%20%20%20%20read_one_byte(%26mut%20self.inner)%0A%20%20%20%20%7D%0A%7D%0A%0A%2F%2F%20utility%20method%0Afn%20read_one_byte(reader%3A%20%26mut%20Read)%20-%3E%20Option%3CResult%3Cu8%3E%3E%20%7B%0A%20%20%20%20let%20mut%20buf%20%3D%20%5B0%5D%3B%0A%20%20%20%20loop%20%7B%0A%20%20%20%20%20%20%20%20return%20match%20reader.read(%26mut%20buf)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20Ok(0)%20%3D%3E%20None%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20Ok(..)%20%3D%3E%20Some(Ok(buf%5B0%5D))%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20Err(ref%20e)%20if%20e.kind()%20%3D%3D%20ErrorKind%3A%3Ainterrupted%20%3D%3E%20continue%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20Err(e)%20%3D%3E%20Some(Err(e))%2C%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Next, there is a method to consume the reader and chains it with another one:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Read</span> {
    <span class='kw'>fn</span> <span class='ident'>chain</span><span class='op'>&lt;</span><span class='ident'>R</span>: <span class='ident'>Read</span><span class='op'>&gt;</span>(<span class='self'>self</span>, <span class='ident'>next</span>: <span class='ident'>R</span>) <span class='op'>-&gt;</span> <span class='ident'>Chain</span><span class='op'>&lt;</span><span class='self'>Self</span>, <span class='ident'>R</span><span class='op'>&gt;</span>
        <span class='kw'>where</span> <span class='self'>Self</span>: <span class='ident'>Sized</span> {
        <span class='ident'>Chain</span> { <span class='ident'>first</span>: <span class='self'>self</span>, <span class='ident'>second</span>: <span class='ident'>next</span>, <span class='ident'>done_first</span>: <span class='bool-val'>false</span>}
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20trait%20Read%20%7B%0A%20%20%20%20fn%20chain%3CR%3A%20Read%3E(self%2C%20next%3A%20R)%20-%3E%20Chain%3CSelf%2C%20R%3E%0A%20%20%20%20%20%20%20%20where%20Self%3A%20Sized%20%7B%0A%20%20%20%20%20%20%20%20Chain%20%7B%20first%3A%20self%2C%20second%3A%20next%2C%20done_first%3A%20false%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>The resultant <code>Chain&lt;Self, R&gt;</code> is also a reader, defined as:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Chain</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>U</span><span class='op'>&gt;</span> {
    <span class='ident'>first</span>: <span class='ident'>T</span>,
    <span class='ident'>second</span>: <span class='ident'>U</span>,
    <span class='ident'>done_first</span>: <span class='ident'>bool</span>,
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Read</span>, <span class='ident'>U</span>: <span class='ident'>Read</span><span class='op'>&gt;</span> <span class='ident'>Read</span> <span class='kw'>for</span> <span class='ident'>Chain</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>U</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>read</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>buf</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='ident'>u8</span>]) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span> {
        <span class='kw'>if</span> <span class='op'>!</span><span class='self'>self</span>.<span class='ident'>done_first</span> {
            <span class='kw'>match</span> <span class='self'>self</span>.<span class='ident'>first</span>.<span class='ident'>read</span>(<span class='ident'>buf</span>)<span class='question-mark'>?</span> {
                <span class='number'>0</span> <span class='kw'>if</span> <span class='ident'>buf</span>.<span class='ident'>len</span>() <span class='op'>!</span><span class='op'>-</span> <span class='number'>0</span> <span class='op'>=&gt;</span> { <span class='self'>self</span>.<span class='ident'>done_first</span> <span class='op'>=</span> <span class='bool-val'>true</span>; }
                <span class='ident'>n</span> <span class='op'>=&gt;</span> <span class='kw'>return</span> <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>),
            }
        }
        <span class='self'>self</span>.<span class='ident'>second</span>.<span class='ident'>read</span>(<span class='ident'>buf</span>)
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20struct%20Chain%3CT%2C%20U%3E%20%7B%0A%20%20%20%20first%3A%20T%2C%0A%20%20%20%20second%3A%20U%2C%0A%20%20%20%20done_first%3A%20bool%2C%0A%7D%0A%0Aimpl%3CT%3A%20Read%2C%20U%3A%20Read%3E%20Read%20for%20Chain%3CT%2C%20U%3E%20%7B%0A%20%20%20%20fn%20read(%26mut%20self%2C%20buf%3A%20%26mut%20%5Bu8%5D)%20-%3E%20Result%3Cusize%3E%20%7B%0A%20%20%20%20%20%20%20%20if%20!self.done_first%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20match%20self.first.read(buf)%3F%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%200%20if%20buf.len()%20!-%200%20%3D%3E%20%7B%20self.done_first%20%3D%20true%3B%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20n%20%3D%3E%20return%20Ok(n)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20self.second.read(buf)%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>It also implements <code>BufRead</code>, which would be covered later.</p>

<p>Finally, the trait defines a <code>take</code> method that consumes <code>self</code> and returns an adaptor that will read at most <code>limit</code> bytes:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Read</span> {
    <span class='kw'>fn</span> <span class='ident'>take</span>(<span class='self'>self</span>, <span class='ident'>limit</span>: <span class='ident'>u64</span>) <span class='op'>-&gt;</span> <span class='ident'>Take</span><span class='op'>&lt;</span><span class='self'>Self</span><span class='op'>&gt;</span> <span class='kw'>where</span> <span class='self'>Self</span>: <span class='ident'>Sized</span> {
        <span class='ident'>Take</span> { <span class='ident'>inner</span>: <span class='self'>self</span>, <span class='ident'>limit</span>: <span class='ident'>limit</span> }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20trait%20Read%20%7B%0A%20%20%20%20fn%20take(self%2C%20limit%3A%20u64)%20-%3E%20Take%3CSelf%3E%20where%20Self%3A%20Sized%20%7B%0A%20%20%20%20%20%20%20%20Take%20%7B%20inner%3A%20self%2C%20limit%3A%20limit%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p><code>Take</code> is defined as follows:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Take</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>inner</span>: <span class='ident'>T</span>,
    <span class='ident'>limit</span>: <span class='ident'>u64</span>,
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Take</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>limit</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>u64</span> { <span class='self'>self</span>.<span class='ident'>limit</span> }

    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>into_inner</span>(<span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>T</span> { <span class='self'>self</span>.<span class='ident'>inner</span> }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Read</span><span class='op'>&gt;</span> <span class='ident'>Read</span> <span class='kw'>for</span> <span class='ident'>Take</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>read</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>buf</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='ident'>u8</span>]) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span> {
        <span class='kw'>if</span> <span class='self'>self</span>.<span class='ident'>limit</span> <span class='op'>==</span> <span class='number'>0</span> { <span class='kw'>return</span> <span class='prelude-val'>Ok</span>(<span class='number'>0</span>);}
        <span class='kw'>let</span> <span class='ident'>max</span> <span class='op'>=</span> <span class='ident'>cmp</span>::<span class='ident'>min</span>(<span class='ident'>buf</span>.<span class='ident'>len</span>() <span class='kw'>as</span> <span class='ident'>u64</span>, <span class='self'>self</span>.<span class='ident'>limit</span>) <span class='kw'>as</span> <span class='ident'>usize</span>;
        <span class='kw'>let</span> <span class='ident'>n</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>inner</span>.<span class='ident'>read</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>buf</span>[..<span class='ident'>max</span>])<span class='question-mark'>?</span>;
        <span class='self'>self</span>.<span class='ident'>limit</span> <span class='op'>-=</span> <span class='ident'>n</span> <span class='kw'>as</span> <span class='ident'>u64</span>;
        <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>)
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20struct%20Take%3CT%3E%20%7B%0A%20%20%20%20inner%3A%20T%2C%0A%20%20%20%20limit%3A%20u64%2C%0A%7D%0A%0Aimpl%3CT%3E%20Take%3CT%3E%20%7B%0A%20%20%20%20pub%20fn%20limit(%26self)%20-%3E%20u64%20%7B%20self.limit%20%7D%0A%0A%20%20%20%20pub%20fn%20into_inner(self)%20-%3E%20T%20%7B%20self.inner%20%7D%0A%7D%0A%0Aimpl%3CT%3A%20Read%3E%20Read%20for%20Take%3CT%3E%20%7B%0A%20%20%20%20fn%20read(%26mut%20self%2C%20buf%3A%20%26mut%20%5Bu8%5D)%20-%3E%20Result%3Cusize%3E%20%7B%0A%20%20%20%20%20%20%20%20if%20self.limit%20%3D%3D%200%20%7B%20return%20Ok(0)%3B%7D%0A%20%20%20%20%20%20%20%20let%20max%20%3D%20cmp%3A%3Amin(buf.len()%20as%20u64%2C%20self.limit)%20as%20usize%3B%0A%20%20%20%20%20%20%20%20let%20n%20%3D%20self.inner.read(%26mut%20buf%5B..max%5D)%3F%3B%0A%20%20%20%20%20%20%20%20self.limit%20-%3D%20n%20as%20u64%3B%0A%20%20%20%20%20%20%20%20Ok(n)%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Notice that the <code>limit</code> field of <code>Take&lt;T&gt;</code> would shrink with any successful <code>read</code>. The type also implements <code>BufRead</code>, which we&#39;d cover later.</p>

<h2 id='write' class='section-header'><a href='#write'>Write</a></h2>
<p>This trait represents a byte sink into which bytes can be written.</p>

<p>It requires two method to be implemented:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Write</span> {
    <span class='kw'>fn</span> <span class='ident'>write</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>buf</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>u8</span>]) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span>;
    <span class='kw'>fn</span> <span class='ident'>flush</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span>;
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20trait%20Write%20%7B%0A%20%20%20%20fn%20write(%26mut%20self%2C%20buf%3A%20%26%5Bu8%5D)%20-%3E%20Result%3Cusize%3E%3B%0A%20%20%20%20fn%20flush(%26mut%20self)%20-%3E%20Result%3C()%3E%3B%0A%7D%0A%7D">Run</a></pre>

<p>The <code>write</code> method tries to write the content of the <code>buf</code> into the writer. But the entire content of the buffer might not be all written. On success the number of bytes actually written would be returned. Calls to <code>write</code> don&#39;t make any assumption about whether the operation would block or not. If the returned value is some <code>Ok(n)</code>, then it must be guaranteed that <code>0 &lt;= n &lt;= buf.len()</code>. Returned value of <code>0</code> typically means that the sink is no longer able to accept bytes anymore (when <code>buf.len() &gt; 0</code>, note that this is not considered as an <code>Err</code>).</p>

<p>The <code>flush</code> method tries to flush the output stream, ensuring that all the intermediately buffered contents reaches their true destination.</p>

<p>additionally, the trait provides</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Write</span> {
    <span class='kw'>fn</span> <span class='ident'>write_all</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='kw-2'>mut</span> <span class='ident'>buf</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>u8</span>]) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span> {
        <span class='kw'>while</span> <span class='op'>!</span><span class='ident'>buf</span>.<span class='ident'>is_empty</span>() {
            <span class='kw'>match</span> <span class='self'>self</span>.<span class='ident'>write</span>(<span class='ident'>buf</span>) {
                <span class='prelude-val'>Ok</span>(<span class='number'>0</span>) <span class='op'>=&gt;</span> <span class='kw'>return</span> <span class='prelude-val'>Err</span>(<span class='ident'>Error</span>::<span class='ident'>new</span>(<span class='ident'>ErrorKind</span>::<span class='ident'>WriteZero</span>, <span class='string'>&quot;failed to write whole buffer&quot;</span>)),
                <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> <span class='ident'>buf</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>buf</span>[<span class='ident'>n</span>..],
                <span class='prelude-val'>Err</span>(<span class='kw-2'>ref</span> <span class='ident'>e</span>) <span class='kw'>if</span> <span class='ident'>e</span>.<span class='ident'>kind</span>() <span class='op'>==</span> <span class='ident'>ErrorKind</span>::<span class='ident'>interrupted</span> <span class='op'>=&gt;</span> {}
                <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> <span class='kw'>return</span> <span class='prelude-val'>Err</span>(<span class='ident'>e</span>),
            }
        }
        <span class='prelude-val'>Ok</span>(())
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20trait%20Write%20%7B%0A%20%20%20%20fn%20write_all(%26mut%20self%2C%20mut%20buf%3A%20%26%5Bu8%5D)%20-%3E%20Result%3C()%3E%20%7B%0A%20%20%20%20%20%20%20%20while%20!buf.is_empty()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20match%20self.write(buf)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Ok(0)%20%3D%3E%20return%20Err(Error%3A%3Anew(ErrorKind%3A%3AWriteZero%2C%20%22failed%20to%20write%20whole%20buffer%22))%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Ok(n)%20%3D%3E%20buf%20%3D%20%26buf%5Bn..%5D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Err(ref%20e)%20if%20e.kind()%20%3D%3D%20ErrorKind%3A%3Ainterrupted%20%3D%3E%20%7B%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Err(e)%20%3D%3E%20return%20Err(e)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20Ok(())%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>The method tries to write all the contents in <code>buf</code> into the sink.</p>

<p>Additional, there is:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Write</span> {
    <span class='kw'>fn</span> <span class='ident'>write_fmt</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>fmt</span>: <span class='ident'>fmt</span>::<span class='ident'>Arguments</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span> {
        <span class='kw'>struct</span> <span class='ident'>Adaptor</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span>: <span class='question-mark'>?</span><span class='ident'>Sized</span> <span class='op'>+</span> <span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
            <span class='ident'>inner</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>T</span>,
            <span class='ident'>error</span>: <span class='prelude-ty'>Result</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span>,
        }

        <span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span>: <span class='ident'>Write</span> <span class='op'>+</span> <span class='question-mark'>?</span><span class='ident'>Sized</span><span class='op'>&gt;</span> <span class='ident'>fmt</span>::<span class='ident'>Write</span> <span class='kw'>for</span> <span class='ident'>Adaptor</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
            <span class='kw'>fn</span> <span class='ident'>write_str</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>s</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='ident'>fmt</span>::<span class='prelude-ty'>Result</span> {
                <span class='kw'>match</span> <span class='self'>self</span>.<span class='ident'>inner</span>.<span class='ident'>write_all</span>(<span class='ident'>s</span>.<span class='ident'>as_bytes</span>()) {
                    <span class='prelude-val'>Ok</span>(()) <span class='op'>=&gt;</span> <span class='prelude-val'>Ok</span>(()),
                    <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> {
                        <span class='self'>self</span>.<span class='ident'>error</span> <span class='op'>=</span> <span class='prelude-val'>Err</span>(<span class='ident'>e</span>);
                        <span class='prelude-val'>Err</span>(<span class='ident'>fmt</span>::<span class='ident'>Error</span>)
                    }
                }
            }
        }

        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>output</span> <span class='op'>=</span> <span class='ident'>Adaptor</span> { <span class='ident'>inner</span>: <span class='self'>self</span>, <span class='ident'>error</span>: <span class='prelude-val'>Ok</span>(()) };
        <span class='kw'>match</span> <span class='ident'>fmt</span>::<span class='ident'>write</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>output</span>, <span class='ident'>fmt</span>) {
            <span class='prelude-val'>Ok</span>(()) <span class='op'>=&gt;</span> <span class='prelude-val'>Ok</span>(()),
            <span class='prelude-val'>Err</span>(..) <span class='op'>=&gt;</span> {
                <span class='kw'>if</span> <span class='ident'>output</span>.<span class='ident'>error</span>.<span class='ident'>is_err</span>() {
                    <span class='ident'>output</span>.<span class='ident'>error</span>
                } <span class='kw'>else</span> {
                    <span class='prelude-val'>Err</span>(<span class='ident'>Error</span>::<span class='ident'>new</span>(<span class='ident'>ErrorKind</span>::<span class='ident'>Other</span>, <span class='string'>&quot;formatter error&quot;</span>))
                }
            }
        }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20trait%20Write%20%7B%0A%20%20%20%20fn%20write_fmt(%26mut%20self%2C%20fmt%3A%20fmt%3A%3AArguments)%20-%3E%20Result%3C()%3E%20%7B%0A%20%20%20%20%20%20%20%20struct%20Adaptor%3C'a%2C%20T%3A%20%3FSized%20%2B%20'a%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20inner%3A%20%26'a%20mut%20T%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20error%3A%20Result%3C()%3E%2C%0A%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20%20%20impl%3C'a%2C%20T%3A%20Write%20%2B%20%3FSized%3E%20fmt%3A%3AWrite%20for%20Adaptor%3C'a%2C%20T%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20fn%20write_str(%26mut%20self%2C%20s%3A%20%26str)%20-%3E%20fmt%3A%3AResult%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20match%20self.inner.write_all(s.as_bytes())%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Ok(())%20%3D%3E%20Ok(())%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Err(e)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20self.error%20%3D%20Err(e)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Err(fmt%3A%3AError)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20%20%20let%20mut%20output%20%3D%20Adaptor%20%7B%20inner%3A%20self%2C%20error%3A%20Ok(())%20%7D%3B%0A%20%20%20%20%20%20%20%20match%20fmt%3A%3Awrite(%26mut%20output%2C%20fmt)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20Ok(())%20%3D%3E%20Ok(())%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20Err(..)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if%20output.error.is_err()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20output.error%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Err(Error%3A%3Anew(ErrorKind%3A%3AOther%2C%20%22formatter%20error%22))%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>This method is primarily used to incoperate with the formatting macros. It is rarelly called alone explicitly. To write a formatted string into the sink, the <code>write!</code> macro should be preferred.</p>

<p>Finally, there is:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Write</span> {
    <span class='kw'>fn</span> <span class='ident'>by_ref</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>Self</span> <span class='kw'>where</span> <span class='self'>Self</span>: <span class='ident'>Sized</span> { <span class='self'>self</span> }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20trait%20Write%20%7B%0A%20%20%20%20fn%20by_ref(%26mut%20self)%20-%3E%20%26mut%20Self%20where%20Self%3A%20Sized%20%7B%20self%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>to get a mutable reference.</p>

<h2 id='seek' class='section-header'><a href='#seek'>Seek</a></h2>
<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Seek</span> {
    <span class='kw'>fn</span> <span class='ident'>seek</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>pos</span>: <span class='ident'>SeekFrom</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>u64</span><span class='op'>&gt;</span>;
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20trait%20Seek%20%7B%0A%20%20%20%20fn%20seek(%26mut%20self%2C%20pos%3A%20SeekFrom)%20-%3E%20Result%3Cu64%3E%3B%0A%7D%0A%7D">Run</a></pre>

<p>The <code>Seek</code> trait represents an IO object with a &quot;cursor&quot;, which represents the current position in the IO stream represented by the object. The required method <code>seek</code> attempts to move that cursor. Suching moving should be relative, thus the possible relative positions (along with how many bytes would be moved) are passed in as the <code>SeekFrom</code> enum, which is defined as:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Copy</span>, <span class='ident'>PartialEq</span>, <span class='ident'>Eq</span>, <span class='ident'>Clone</span>, <span class='ident'>Debug</span>)]</span>
<span class='kw'>pub</span> <span class='kw'>enum</span> <span class='ident'>SeekFrom</span> {
    <span class='ident'>Start</span>(<span class='ident'>u64</span>),
    <span class='ident'>End</span>(<span class='ident'>i64</span>),
    <span class='ident'>Current</span>(<span class='ident'>i64</span>),
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%23%5Bderive(Copy%2C%20PartialEq%2C%20Eq%2C%20Clone%2C%20Debug)%5D%0Apub%20enum%20SeekFrom%20%7B%0A%20%20%20%20Start(u64)%2C%0A%20%20%20%20End(i64)%2C%0A%20%20%20%20Current(i64)%2C%0A%7D%0A%7D">Run</a></pre>

<p>The <code>Start</code> variant means an offset from the &quot;start&quot; of the stream. It contains a <code>u64</code>, thus, only seeking <em>after</em> the starting point is valid. The <code>End</code> variant means an offset from the &quot;end&quot; of the stream, containing an <code>i64</code>, it is considered valid to seek before and beyond the ending point of the stream. The <code>Current</code> variant means an offset from the &quot;current&quot; position in the stream.</p>

<p>The <code>seek</code> method takes such an offset, and tries to move the cursor to the specified position. If the invocation succeed, the returned <code>Result</code> would be the distance from the starting point to the new position.</p>

<h2 id='bufread' class='section-header'><a href='#bufread'>BufRead</a></h2>
<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>BufRead</span>: <span class='ident'>Read</span> {
    <span class='kw'>fn</span> <span class='ident'>fill_buf</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span>[<span class='ident'>u8</span>]<span class='op'>&gt;</span>;
    <span class='kw'>fn</span> <span class='ident'>consume</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>amt</span>: <span class='ident'>usize</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20trait%20BufRead%3A%20Read%20%7B%0A%20%20%20%20fn%20fill_buf(%26mut%20self)%20-%3E%20Result%3C%26%5Bu8%5D%3E%3B%0A%20%20%20%20fn%20consume(%26mut%20self%2C%20amt%3A%20usize)%3B%0A%7D%0A%7D">Run</a></pre>

<p><code>BufRead</code> represents a specific type of <code>Read</code>er that has an internal buffer. Having a buffer allows extra ways of reading to become efficient.</p>

<p>The trait requirs two methods to be implemented.</p>

<p><code>fill_buf</code> should fill the internal buffer of the object, returning the buffer contents upon success. <code>buf.consume(amt)</code> tells the buffer that <code>amt</code> bytes have been consumed from the internal buffer, thus should no longer be returned be suceeding <code>read</code>ings. These two functions are relatively low-level and should be used in pair.</p>

<p>With these two methods implemented, the trait provides some high-level utility methods for daily use:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>BufRead</span>: <span class='ident'>Read</span> {
    <span class='kw'>fn</span> <span class='ident'>read_until</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>byte</span>: <span class='ident'>u8</span>, <span class='ident'>buf</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span> {
        <span class='ident'>read_until</span>(<span class='self'>self</span>, <span class='ident'>byte</span>, <span class='ident'>buf</span>)
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20trait%20BufRead%3A%20Read%20%7B%0A%20%20%20%20fn%20read_until(%26mut%20self%2C%20byte%3A%20u8%2C%20buf%3A%20%26mut%20Vec%3Cu8%3E)%20-%3E%20Result%3Cusize%3E%20%7B%0A%20%20%20%20%20%20%20%20read_until(self%2C%20byte%2C%20buf)%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>The method tries to read all bytes into <code>buf</code> until the delimiter <code>byte</code> or EOF is reached. The delimiter (if found) will also be appended to the target <code>byf</code>, Upon success, the function will return the total bytes read. Internally, it forwards the call to the implementation function, which is defined as:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>read_until</span><span class='op'>&lt;</span><span class='ident'>R</span><span class='op'>&gt;</span>(<span class='ident'>r</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>R</span>, <span class='ident'>delim</span>: <span class='ident'>u8</span>, <span class='ident'>buf</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>read</span> <span class='op'>=</span> <span class='number'>0</span>;
    <span class='kw'>loop</span> {
        <span class='kw'>let</span> (<span class='ident'>done</span>, <span class='ident'>used</span>) <span class='op'>=</span> {
            <span class='kw'>let</span> <span class='ident'>available</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>r</span>.<span class='ident'>fill_buf</span>() {
                <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>) <span class='op'>=</span> <span class='ident'>n</span>,
                <span class='prelude-val'>Err</span>(<span class='kw-2'>ref</span> <span class='ident'>e</span>) <span class='kw'>if</span> <span class='ident'>e</span>.<span class='ident'>kind</span> <span class='op'>==</span> <span class='ident'>ErrorKind</span>::<span class='ident'>interrupted</span> <span class='op'>=&gt;</span> <span class='kw'>continue</span>,
                <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> <span class='kw'>return</span> <span class='prelude-val'>Err</span>(<span class='ident'>e</span>)
            };

            <span class='kw'>match</span> <span class='ident'>memchr</span>::<span class='ident'>memchr</span>(<span class='ident'>delim</span>, <span class='ident'>available</span>) {
                <span class='prelude-val'>Some</span>(<span class='ident'>i</span>) <span class='op'>=&gt;</span> {
                    <span class='ident'>buf</span>.<span class='ident'>extend_from_slice</span>(<span class='kw-2'>&amp;</span><span class='ident'>available</span>[..<span class='ident'>i</span><span class='op'>+</span><span class='number'>1</span>]);
                    (<span class='bool-val'>true</span>, <span class='ident'>i</span><span class='op'>+</span><span class='number'>1</span>)
                }
                <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> {
                    <span class='ident'>buf</span>.<span class='ident'>extend_from_slice</span>(<span class='ident'>available</span>);
                    (<span class='bool-val'>false</span>, <span class='ident'>available</span>.<span class='ident'>len</span>())
                }
            }
        };
        <span class='ident'>r</span>.<span class='ident'>consume</span>(<span class='ident'>used</span>);
        <span class='ident'>read</span> <span class='op'>+=</span> <span class='ident'>used</span>;
        <span class='kw'>if</span> <span class='ident'>done</span> <span class='op'>||</span> <span class='ident'>used</span> <span class='op'>==</span> <span class='number'>0</span> {
            <span class='kw'>return</span> <span class='prelude-val'>Ok</span>(<span class='ident'>read</span>)
        }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20read_until%3CR%3E(r%3A%20%26mut%20R%2C%20delim%3A%20u8%2C%20buf%3A%20%26mut%20Vec%3Cu8%3E)%20-%3E%20Result%3Cusize%3E%20%7B%0A%20%20%20%20let%20mut%20read%20%3D%200%3B%0A%20%20%20%20loop%20%7B%0A%20%20%20%20%20%20%20%20let%20(done%2C%20used)%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20available%20%3D%20match%20r.fill_buf()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Ok(n)%20%3D%20n%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Err(ref%20e)%20if%20e.kind%20%3D%3D%20ErrorKind%3A%3Ainterrupted%20%3D%3E%20continue%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Err(e)%20%3D%3E%20return%20Err(e)%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20match%20memchr%3A%3Amemchr(delim%2C%20available)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Some(i)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20buf.extend_from_slice(%26available%5B..i%2B1%5D)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20(true%2C%20i%2B1)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20None%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20buf.extend_from_slice(available)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20(false%2C%20available.len())%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%20%20%20%20r.consume(used)%3B%0A%20%20%20%20%20%20%20%20read%20%2B%3D%20used%3B%0A%20%20%20%20%20%20%20%20if%20done%20%7C%7C%20used%20%3D%3D%200%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20Ok(read)%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>The function also demonstrates the usage of <code>fill_buf</code> and <code>consume</code>. The function calls <code>r.fill_buf</code> inside a loop to fill the internal buffer of <code>r</code> and returns a reference of it (<code>available</code>) if the operation succeed. It then uses the extremely fast <code>memchr::memchr</code> to find the delimiter <code>delim</code> in <code>available</code>. If found, the bytes from the start to the undex of delimiter in the internal buffer would be consumed and appended into the target buffer. If not, all the bytes in the internal buffer would be consumed into the target buffer. Depending on whether the delimiter has been found or EOF has been reached (indicated by 0 bytes available in the internal buffer), the function would jump out of the loop and return the total bytes read.</p>

<p>Additionally, the trait provides:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>BufRead</span> {
    <span class='kw'>fn</span> <span class='ident'>read_line</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>buf</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>String</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span> {
        <span class='ident'>append_to_string</span>(<span class='ident'>buf</span>, <span class='op'>|</span><span class='ident'>b</span><span class='op'>|</span> <span class='ident'>read_until</span>(<span class='self'>self</span>, <span class='string'>b&#39;\n&#39;</span>, <span class='ident'>b</span>))
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20trait%20BufRead%20%7B%0A%20%20%20%20fn%20read_line(%26mut%20self%2C%20buf%3A%20%26mut%20String)%20-%3E%20Result%3Cusize%3E%20%7B%0A%20%20%20%20%20%20%20%20append_to_string(buf%2C%20%7Cb%7C%20read_until(self%2C%20b'%5Cn'%2C%20b))%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>which would attempt to read all bytes until a newline character (<code>0xa</code> byte) is reached. The bytes read would be appended to the provided <code>String</code> buffer if they form valid UTF8.</p>

<p>Internally, it makes use of the <code>append_to_string</code> function, which was introduced above. Now we&#39;ve uncovered the reason of this function&#39;s signature design: reduce code dulplication.</p>

<p>The trait also provides</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>BufRead</span> {
    <span class='kw'>fn</span> <span class='ident'>split</span>(<span class='self'>self</span>, <span class='ident'>byte</span>: <span class='ident'>u8</span>) <span class='op'>-&gt;</span> <span class='ident'>Split</span><span class='op'>&lt;</span><span class='self'>Self</span><span class='op'>&gt;</span> <span class='kw'>where</span> <span class='self'>Self</span>: <span class='ident'>Sized</span> {
        <span class='ident'>Split</span> { <span class='ident'>buf</span>: <span class='self'>self</span>, <span class='ident'>delim</span>: <span class='ident'>byte</span> }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20trait%20BufRead%20%7B%0A%20%20%20%20fn%20split(self%2C%20byte%3A%20u8)%20-%3E%20Split%3CSelf%3E%20where%20Self%3A%20Sized%20%7B%0A%20%20%20%20%20%20%20%20Split%20%7B%20buf%3A%20self%2C%20delim%3A%20byte%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>which would consume this reader and returns an iterator over the contents of it, split on the <code>byte</code> given.</p>

<p>The iterator is defined as:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Split</span><span class='op'>&lt;</span><span class='ident'>B</span><span class='op'>&gt;</span> {
    <span class='ident'>buf</span>: <span class='ident'>B</span>,
    <span class='ident'>delim</span>: <span class='ident'>u8</span>,
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>B</span>: <span class='ident'>BufRead</span><span class='op'>&gt;</span> <span class='ident'>Iterator</span> <span class='kw'>for</span> <span class='ident'>Split</span><span class='op'>&lt;</span><span class='ident'>B</span><span class='op'>&gt;</span> {
    <span class='kw'>type</span> <span class='ident'>Item</span> <span class='op'>=</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;&gt;</span>;

    <span class='kw'>fn</span> <span class='ident'>next</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;&gt;</span><span class='op'>&gt;</span> {
        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>buf</span> <span class='op'>=</span> <span class='ident'>Vec</span>::<span class='ident'>new</span>();
        <span class='kw'>match</span> <span class='self'>self</span>.<span class='ident'>buf</span>.<span class='ident'>read_until</span>(<span class='self'>self</span>.<span class='ident'>delim</span>, <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>buf</span>) {
            <span class='prelude-val'>Ok</span>(<span class='number'>0</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>None</span>, <span class='comment'>// the underlying reader has reached EOF, so return `None`</span>
            <span class='prelude-val'>Ok</span>(<span class='ident'>_n</span>) <span class='op'>=&gt;</span> {
                <span class='kw'>if</span> <span class='ident'>buf</span>[<span class='ident'>buf</span>.<span class='ident'>len</span>() <span class='op'>-</span> <span class='number'>1</span>] <span class='op'>==</span> <span class='self'>self</span>.<span class='ident'>delim</span> {
                    <span class='ident'>buf</span>.<span class='ident'>pop</span>(); <span class='comment'>// the last byte is the delimiter, so pop it out</span>
                }
                <span class='prelude-val'>Some</span>(<span class='prelude-val'>Ok</span>(<span class='ident'>buf</span>))
            }
            <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='prelude-val'>Err</span>(<span class='ident'>e</span>))
        }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20struct%20Split%3CB%3E%20%7B%0A%20%20%20%20buf%3A%20B%2C%0A%20%20%20%20delim%3A%20u8%2C%0A%7D%0A%0Aimpl%3CB%3A%20BufRead%3E%20Iterator%20for%20Split%3CB%3E%20%7B%0A%20%20%20%20type%20Item%20%3D%20Result%3CVec%3Cu8%3E%3E%3B%0A%0A%20%20%20%20fn%20next(%26mut%20self)%20-%3E%20Option%3CResult%3CVec%3Cu8%3E%3E%3E%20%7B%0A%20%20%20%20%20%20%20%20let%20mut%20buf%20%3D%20Vec%3A%3Anew()%3B%0A%20%20%20%20%20%20%20%20match%20self.buf.read_until(self.delim%2C%20%26mut%20buf)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20Ok(0)%20%3D%3E%20None%2C%20%2F%2F%20the%20underlying%20reader%20has%20reached%20EOF%2C%20so%20return%20%60None%60%0A%20%20%20%20%20%20%20%20%20%20%20%20Ok(_n)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if%20buf%5Bbuf.len()%20-%201%5D%20%3D%3D%20self.delim%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20buf.pop()%3B%20%2F%2F%20the%20last%20byte%20is%20the%20delimiter%2C%20so%20pop%20it%20out%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Some(Ok(buf))%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20Err(e)%20%3D%3E%20Some(Err(e))%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Note that the iterator yields a <code>Result&lt;Vec&lt;u8&gt;&gt;</code>, meaning that the last <code>Err</code> encountered will be propagated and returned to the caller of the trait.</p>

<p>Finally, the tarit provides</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>BufRead</span> {
    <span class='kw'>fn</span> <span class='ident'>lines</span>(<span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>Lines</span><span class='op'>&lt;</span><span class='self'>Self</span><span class='op'>&gt;</span> <span class='kw'>where</span> <span class='self'>Self</span>: <span class='ident'>Sized</span> {
        <span class='ident'>Lines</span>{ <span class='ident'>buf</span>: <span class='self'>self</span> }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20trait%20BufRead%20%7B%0A%20%20%20%20fn%20lines(self)%20-%3E%20Lines%3CSelf%3E%20where%20Self%3A%20Sized%20%7B%0A%20%20%20%20%20%20%20%20Lines%7B%20buf%3A%20self%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>which consumes the reader and returns an iterator over the lines of it content.</p>

<p>The definition of the returned struct is similar to <code>Split</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Lines</span><span class='op'>&lt;</span><span class='ident'>B</span><span class='op'>&gt;</span> {
    <span class='ident'>buf</span>: <span class='ident'>B</span>,
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>B</span>: <span class='ident'>BufRead</span><span class='op'>&gt;</span> <span class='ident'>Iterator</span> <span class='kw'>for</span> <span class='ident'>Lines</span><span class='op'>&lt;</span><span class='ident'>B</span><span class='op'>&gt;</span> {
    <span class='kw'>type</span> <span class='ident'>Item</span> <span class='op'>=</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>String</span><span class='op'>&gt;</span>;

    <span class='kw'>fn</span> <span class='ident'>next</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>String</span><span class='op'>&gt;&gt;</span> {
        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>buf</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
        <span class='kw'>match</span> <span class='self'>self</span>.<span class='ident'>buf</span>.<span class='ident'>read_line</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>buf</span>) {
            <span class='prelude-val'>Ok</span>(<span class='number'>0</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>None</span>,
            <span class='prelude-val'>Ok</span>(<span class='ident'>_n</span>) <span class='op'>=&gt;</span> {
                <span class='kw'>if</span> <span class='ident'>buf</span>.<span class='ident'>ends_with</span>(<span class='string'>&quot;\n&quot;</span>) {
                    <span class='ident'>buf</span>.<span class='ident'>pop</span>();
                    <span class='kw'>if</span> <span class='ident'>buf</span>.<span class='ident'>ends_with</span>(<span class='string'>&quot;\r&quot;</span>) {
                        <span class='ident'>buf</span>.<span class='ident'>pop</span>();
                    }
                }
                <span class='prelude-val'>Some</span>(<span class='prelude-val'>Ok</span>(<span class='ident'>buf</span>))
            }
            <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='prelude-val'>Err</span>(<span class='ident'>e</span>))
        }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20struct%20Lines%3CB%3E%20%7B%0A%20%20%20%20buf%3A%20B%2C%0A%7D%0A%0Aimpl%3CB%3A%20BufRead%3E%20Iterator%20for%20Lines%3CB%3E%20%7B%0A%20%20%20%20type%20Item%20%3D%20Result%3CString%3E%3B%0A%0A%20%20%20%20fn%20next(%26mut%20self)%20-%3E%20Option%3CResult%3CString%3E%3E%20%7B%0A%20%20%20%20%20%20%20%20let%20mut%20buf%20%3D%20String%3A%3Anew()%3B%0A%20%20%20%20%20%20%20%20match%20self.buf.read_line(%26mut%20buf)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20Ok(0)%20%3D%3E%20None%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20Ok(_n)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if%20buf.ends_with(%22%5Cn%22)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20buf.pop()%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if%20buf.ends_with(%22%5Cr%22)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20buf.pop()%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Some(Ok(buf))%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20Err(e)%20%3D%3E%20Some(Err(e))%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Note that it uses an additional <code>if</code> to deal with <code>/r</code>.</p>

<h1 id='buffered-io' class='section-header'><a href='#buffered-io'>Buffered IO</a></h1>
<p>IO often requiers a lot of interaction with some sort of &quot;external device&quot;, which might be really inefficient. As such, buffering is commonly used to help reduce the overhead. To capture this pattern, besides the <code>BufRead</code> trait, the module also provides three wrapper structs.</p>

<h2 id='bufreader' class='section-header'><a href='#bufreader'>BufReader</a></h2>
<p>First comes the <code>BufReader</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>BufReader</span><span class='op'>&lt;</span><span class='ident'>R</span><span class='op'>&gt;</span> {
    <span class='ident'>inner</span>: <span class='ident'>R</span>,
    <span class='ident'>buf</span>: <span class='ident'>Box</span><span class='op'>&lt;</span>[<span class='ident'>u8</span>]<span class='op'>&gt;</span>,
    <span class='ident'>pos</span>: <span class='ident'>usize</span>, <span class='comment'>// current position into the buffer</span>
    <span class='ident'>cap</span>: <span class='ident'>usize</span>, <span class='comment'>// total buffered bytes in the buffer</span>
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20struct%20BufReader%3CR%3E%20%7B%0A%20%20%20%20inner%3A%20R%2C%0A%20%20%20%20buf%3A%20Box%3C%5Bu8%5D%3E%2C%0A%20%20%20%20pos%3A%20usize%2C%20%2F%2F%20current%20position%20into%20the%20buffer%0A%20%20%20%20cap%3A%20usize%2C%20%2F%2F%20total%20buffered%20bytes%20in%20the%20buffer%0A%7D%0A%7D">Run</a></pre>

<p>It is meant to be a buffered wrapper around another reader of type <code>R</code>. To construct it, the module exposes:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>R</span>: <span class='ident'>Read</span><span class='op'>&gt;</span> <span class='ident'>BufReader</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>inner</span>: <span class='ident'>R</span>) <span class='op'>-&gt;</span> <span class='ident'>BufReader</span><span class='op'>&lt;</span><span class='ident'>R</span><span class='op'>&gt;</span> {
        <span class='ident'>BufReader</span>::<span class='ident'>with_capacity</span>(<span class='ident'>DEFAULT_BUF_SIZE</span>, <span class='ident'>inner</span>)
    }

    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>with_capacity</span>(<span class='ident'>cap</span>: <span class='ident'>usize</span>, <span class='ident'>inner</span>: <span class='ident'>R</span>) <span class='op'>-&gt;</span> <span class='ident'>BufReader</span><span class='op'>&lt;</span><span class='ident'>R</span><span class='op'>&gt;</span> {
        <span class='ident'>BufReader</span> {
            <span class='ident'>inner</span>: <span class='ident'>inner</span>,
            <span class='ident'>buf</span>: <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>0</span>; <span class='ident'>cap</span>].<span class='ident'>into_boxed_slice</span>(),
            <span class='ident'>pos</span>: <span class='number'>0</span>,
            <span class='ident'>cap</span>: <span class='number'>0</span>,
        }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%3CR%3A%20Read%3E%20BufReader%3CT%3E%20%7B%0A%20%20%20%20pub%20fn%20new(inner%3A%20R)%20-%3E%20BufReader%3CR%3E%20%7B%0A%20%20%20%20%20%20%20%20BufReader%3A%3Awith_capacity(DEFAULT_BUF_SIZE%2C%20inner)%0A%20%20%20%20%7D%0A%0A%20%20%20%20pub%20fn%20with_capacity(cap%3A%20usize%2C%20inner%3A%20R)%20-%3E%20BufReader%3CR%3E%20%7B%0A%20%20%20%20%20%20%20%20BufReader%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20inner%3A%20inner%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20buf%3A%20vec!%5B0%3B%20cap%5D.into_boxed_slice()%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20pos%3A%200%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20cap%3A%200%2C%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Note that once constructed the capacity of the internal buffer can&#39;t be changed.</p>

<p>As expected, the struct implements <code>BufRead</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>R</span>: <span class='ident'>Read</span><span class='op'>&gt;</span> <span class='ident'>BufRead</span> <span class='kw'>for</span> <span class='ident'>BufReader</span><span class='op'>&lt;</span><span class='ident'>R</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>fill_buf</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span>[<span class='ident'>u8</span>]<span class='op'>&gt;</span> {
        <span class='kw'>if</span> <span class='self'>self</span>.<span class='ident'>pos</span> <span class='op'>&gt;=</span> <span class='self'>self</span>.<span class='ident'>cap</span> { <span class='comment'>// buffered bytes all consumed</span>
            <span class='macro'>debug_assert_eq</span><span class='macro'>!</span>(<span class='self'>self</span>.<span class='ident'>pos</span>, <span class='self'>self</span>.<span class='ident'>cap</span>);

            <span class='comment'>// fetch more from the inner buffer, propagate any error</span>
            <span class='self'>self</span>.<span class='ident'>cap</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>inner</span>.<span class='ident'>read</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>.<span class='ident'>buf</span>)<span class='question-mark'>?</span>;

            <span class='comment'>// reset the current `pos`</span>
            <span class='self'>self</span>.<span class='ident'>pos</span> <span class='op'>=</span> <span class='number'>0</span>;
        }

        <span class='comment'>// return the bytes available</span>
        <span class='prelude-val'>Ok</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>.<span class='ident'>buf</span>[<span class='self'>self</span>.<span class='ident'>pos</span>..<span class='self'>self</span>.<span class='ident'>cap</span>])
    }

    <span class='kw'>fn</span> <span class='ident'>consume</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>amt</span>: <span class='ident'>usize</span>) {
        <span class='comment'>// consume `amt` bytes. make sure that `pos` do not go beyond `cap`.</span>
        <span class='self'>self</span>.<span class='ident'>pos</span> <span class='op'>=</span> <span class='ident'>cmp</span>::<span class='ident'>min</span>(<span class='self'>self</span>.<span class='ident'>pos</span> <span class='op'>+</span> <span class='ident'>amt</span>, <span class='self'>self</span>.<span class='ident'>cap</span>);
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>R</span>: <span class='ident'>Read</span><span class='op'>&gt;</span> <span class='ident'>Read</span> <span class='kw'>for</span> <span class='ident'>BufReader</span><span class='op'>&lt;</span><span class='ident'>R</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>read</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>buf</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='ident'>u8</span>]) <span class='op'>-&gt;</span> <span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span> {
        <span class='kw'>if</span> <span class='self'>self</span>.<span class='ident'>pos</span> <span class='op'>==</span> <span class='self'>self</span>.<span class='ident'>cap</span> <span class='op'>&amp;&amp;</span> <span class='ident'>buf</span>.<span class='ident'>len</span>() <span class='op'>&gt;=</span> <span class='self'>self</span>.<span class='ident'>buf</span>.<span class='ident'>len</span>() {
            <span class='comment'>// We don&#39;t have any bytes buffered internally,</span>
            <span class='comment'>// and the provided buffer&#39;s capacity is greater than</span>
            <span class='comment'>// our internal buffer&#39;s size, so buffering is of no use,</span>
            <span class='comment'>// we thus bypass our internal buffer</span>
            <span class='kw'>return</span> <span class='self'>self</span>.<span class='ident'>inner</span>.<span class='ident'>read</span>(<span class='ident'>buf</span>);
        }

         <span class='comment'>// else, let&#39;s fetch some data from the internal buffer</span>
        <span class='kw'>let</span> <span class='ident'>nread</span> <span class='op'>=</span> {
            <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rem</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>fill_buf</span>()<span class='question-mark'>?</span>;
            <span class='ident'>rem</span>.<span class='ident'>read</span>(<span class='ident'>buf</span>)<span class='question-mark'>?</span> <span class='comment'>// note that `[u8]` also implements `Read`, so this invocation is possible</span>
        };
        <span class='self'>self</span>.<span class='ident'>consume</span>(<span class='ident'>nread</span>); <span class='comment'>// then we `consume` these bytes</span>
        <span class='prelude-val'>Ok</span>(<span class='ident'>nread</span>) <span class='comment'>// and return the bytes consumed</span>
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%3CR%3A%20Read%3E%20BufRead%20for%20BufReader%3CR%3E%20%7B%0A%20%20%20%20fn%20fill_buf(%26mut%20self)%20-%3E%20io%3A%3AResult%3C%26%5Bu8%5D%3E%20%7B%0A%20%20%20%20%20%20%20%20if%20self.pos%20%3E%3D%20self.cap%20%7B%20%2F%2F%20buffered%20bytes%20all%20consumed%0A%20%20%20%20%20%20%20%20%20%20%20%20debug_assert_eq!(self.pos%2C%20self.cap)%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20fetch%20more%20from%20the%20inner%20buffer%2C%20propagate%20any%20error%0A%20%20%20%20%20%20%20%20%20%20%20%20self.cap%20%3D%20self.inner.read(%26mut%20self.buf)%3F%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20reset%20the%20current%20%60pos%60%0A%20%20%20%20%20%20%20%20%20%20%20%20self.pos%20%3D%200%3B%0A%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20%20%20%2F%2F%20return%20the%20bytes%20available%0A%20%20%20%20%20%20%20%20Ok(%26self.buf%5Bself.pos..self.cap%5D)%0A%20%20%20%20%7D%0A%0A%20%20%20%20fn%20consume(%26mut%20self%2C%20amt%3A%20usize)%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20consume%20%60amt%60%20bytes.%20make%20sure%20that%20%60pos%60%20do%20not%20go%20beyond%20%60cap%60.%0A%20%20%20%20%20%20%20%20self.pos%20%3D%20cmp%3A%3Amin(self.pos%20%2B%20amt%2C%20self.cap)%3B%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%3CR%3A%20Read%3E%20Read%20for%20BufReader%3CR%3E%20%7B%0A%20%20%20%20fn%20read(%26mut%20self%2C%20buf%3A%20%26mut%20%5Bu8%5D)%20-%3E%20io%3A%3AResult%3Cusize%3E%20%7B%0A%20%20%20%20%20%20%20%20if%20self.pos%20%3D%3D%20self.cap%20%26%26%20buf.len()%20%3E%3D%20self.buf.len()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20We%20don't%20have%20any%20bytes%20buffered%20internally%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20and%20the%20provided%20buffer's%20capacity%20is%20greater%20than%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20our%20internal%20buffer's%20size%2C%20so%20buffering%20is%20of%20no%20use%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20we%20thus%20bypass%20our%20internal%20buffer%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20self.inner.read(buf)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20%20%20%20%2F%2F%20else%2C%20let's%20fetch%20some%20data%20from%20the%20internal%20buffer%0A%20%20%20%20%20%20%20%20let%20nread%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20mut%20rem%20%3D%20self.fill_buf()%3F%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20rem.read(buf)%3F%20%2F%2F%20note%20that%20%60%5Bu8%5D%60%20also%20implements%20%60Read%60%2C%20so%20this%20invocation%20is%20possible%0A%20%20%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%20%20%20%20self.consume(nread)%3B%20%2F%2F%20then%20we%20%60consume%60%20these%20bytes%0A%20%20%20%20%20%20%20%20Ok(nread)%20%2F%2F%20and%20return%20the%20bytes%20consumed%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Additionally, for seekable inner reader, the wrapper also implements <code>Seek</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>R</span>: <span class='ident'>Seek</span><span class='op'>&gt;</span> <span class='ident'>Seek</span> <span class='kw'>for</span> <span class='ident'>BufReader</span><span class='op'>&lt;</span><span class='ident'>R</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>seek</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>pos</span>: <span class='ident'>SeekFrom</span>) <span class='op'>-&gt;</span> <span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>u64</span><span class='op'>&gt;</span> {
        <span class='kw'>let</span> <span class='ident'>result</span>: <span class='ident'>u64</span>;
        <span class='kw'>if</span> <span class='kw'>let</span> <span class='ident'>SeekFrom</span>::<span class='ident'>Current</span>(<span class='ident'>n</span>) <span class='op'>=</span> <span class='ident'>pos</span> {
            <span class='kw'>let</span> <span class='ident'>remainder</span> <span class='op'>=</span> (<span class='self'>self</span>.<span class='ident'>cap</span> <span class='op'>-</span> <span class='self'>self</span>.<span class='ident'>pos</span>) <span class='kw'>as</span> <span class='ident'>i64</span>;
            
            <span class='comment'>// use `checked_sub` to deal with possible underflow</span>
            <span class='kw'>if</span> <span class='kw'>let</span> <span class='prelude-val'>Some</span>(<span class='ident'>offset</span>) <span class='op'>=</span> <span class='ident'>n</span>.<span class='ident'>checked_sub</span>(<span class='ident'>remainder</span>) {
                <span class='ident'>result</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>inner</span>.<span class='ident'>seek</span>(<span class='ident'>SeekFrom</span>::<span class='ident'>Current</span>(<span class='ident'>offset</span>))<span class='question-mark'>?</span>;
            } <span class='kw'>else</span> {
                <span class='comment'>// can&#39;t seek by the actual offset, so we seek twice</span>
                <span class='self'>self</span>.<span class='ident'>inner</span>.<span class='ident'>seek</span>(<span class='ident'>SeekFrom</span>::<span class='ident'>Current</span>(<span class='op'>-</span><span class='ident'>remainder</span>))<span class='question-mark'>?</span>;
                <span class='self'>self</span>.<span class='ident'>pos</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>cap</span>; <span class='comment'>// effectively, this empties the inner buffer</span>
                                     <span class='comment'>// this is needed so that if any `Err` occurs</span>
                                     <span class='comment'>// and the function is returned in the next</span>
                                     <span class='comment'>// statement, the whole inner buffer would be</span>
                                     <span class='comment'>// left in a valid state</span>
                <span class='ident'>result</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>inner</span>.<span class='ident'>seek</span>(<span class='ident'>SeekFrom</span>::<span class='ident'>Current</span>(<span class='ident'>n</span>))<span class='question-mark'>?</span>;
            }
        } <span class='kw'>else</span> {
            <span class='comment'>// Seeking from `Start` or `End` doesn&#39;t care about the current pos</span>
            <span class='ident'>result</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>inner</span>.<span class='ident'>seek</span>(<span class='ident'>pos</span>)<span class='question-mark'>?</span>;
        }
        <span class='self'>self</span>.<span class='ident'>pos</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>cap</span>; <span class='comment'>// empty the inner buffer</span>
        <span class='prelude-val'>Ok</span>(<span class='ident'>result</span>)
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%3CR%3A%20Seek%3E%20Seek%20for%20BufReader%3CR%3E%20%7B%0A%20%20%20%20fn%20seek(%26mut%20self%2C%20pos%3A%20SeekFrom)%20-%3E%20io%3A%3AResult%3Cu64%3E%20%7B%0A%20%20%20%20%20%20%20%20let%20result%3A%20u64%3B%0A%20%20%20%20%20%20%20%20if%20let%20SeekFrom%3A%3ACurrent(n)%20%3D%20pos%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20remainder%20%3D%20(self.cap%20-%20self.pos)%20as%20i64%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20use%20%60checked_sub%60%20to%20deal%20with%20possible%20underflow%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20let%20Some(offset)%20%3D%20n.checked_sub(remainder)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20result%20%3D%20self.inner.seek(SeekFrom%3A%3ACurrent(offset))%3F%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20can't%20seek%20by%20the%20actual%20offset%2C%20so%20we%20seek%20twice%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20self.inner.seek(SeekFrom%3A%3ACurrent(-remainder))%3F%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20self.pos%20%3D%20self.cap%3B%20%2F%2F%20effectively%2C%20this%20empties%20the%20inner%20buffer%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20this%20is%20needed%20so%20that%20if%20any%20%60Err%60%20occurs%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20and%20the%20function%20is%20returned%20in%20the%20next%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20statement%2C%20the%20whole%20inner%20buffer%20would%20be%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20left%20in%20a%20valid%20state%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20result%20%3D%20self.inner.seek(SeekFrom%3A%3ACurrent(n))%3F%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20Seeking%20from%20%60Start%60%20or%20%60End%60%20doesn't%20care%20about%20the%20current%20pos%0A%20%20%20%20%20%20%20%20%20%20%20%20result%20%3D%20self.inner.seek(pos)%3F%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20self.pos%20%3D%20self.cap%3B%20%2F%2F%20empty%20the%20inner%20buffer%0A%20%20%20%20%20%20%20%20Ok(result)%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>The wrapper also provides some methods to convert to the underlying reader. Note that, during these conversions, leftover bytes in the wrapper&#39;s internal buffer is ignored. Thus they should be used with caution.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>R</span>: <span class='ident'>Read</span><span class='op'>&gt;</span> <span class='ident'>BufReader</span><span class='op'>&lt;</span><span class='ident'>R</span><span class='op'>&gt;</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>get_ref</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='ident'>R</span> { <span class='kw-2'>&amp;</span><span class='self'>self</span>.<span class='ident'>inner</span> }
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>get_mut</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>R</span> { <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>.<span class='ident'>inner</span> }
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>into_inner</span>(<span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>R</span> { <span class='self'>self</span>.<span class='ident'>inner</span> }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%3CR%3A%20Read%3E%20BufReader%3CR%3E%20%7B%0A%20%20%20%20pub%20fn%20get_ref(%26self)%20-%3E%20%26R%20%7B%20%26self.inner%20%7D%0A%20%20%20%20pub%20fn%20get_mut(%26mut%20self)%20-%3E%20%26mut%20R%20%7B%20%26mut%20self.inner%20%7D%0A%20%20%20%20pub%20fn%20into_inner(self)%20-%3E%20R%20%7B%20self.inner%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Additionally, the wrapper implements <code>Debug</code> for <code>R: Debug</code>.</p>

<h2 id='bufwriter' class='section-header'><a href='#bufwriter'>BufWriter</a></h2>
<p>Analog to <code>BufReader</code>, <code>BufWriter</code> maintains an in-memory buffer for a wrapped writer.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>BufWriter</span><span class='op'>&lt;</span><span class='ident'>W</span>: <span class='ident'>Write</span><span class='op'>&gt;</span> {
    <span class='ident'>inner</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>W</span><span class='op'>&gt;</span>,
    <span class='ident'>buf</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;</span>,
    <span class='ident'>panicked</span>: <span class='ident'>bool</span>,
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20struct%20BufWriter%3CW%3A%20Write%3E%20%7B%0A%20%20%20%20inner%3A%20Option%3CW%3E%2C%0A%20%20%20%20buf%3A%20Vec%3Cu8%3E%2C%0A%20%20%20%20panicked%3A%20bool%2C%0A%7D%0A%7D">Run</a></pre>

<p>To construct it:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>W</span>: <span class='ident'>Write</span><span class='op'>&gt;</span> <span class='ident'>BufWriter</span><span class='op'>&lt;</span><span class='ident'>W</span><span class='op'>&gt;</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>inner</span>: <span class='ident'>W</span>) <span class='op'>-&gt;</span> <span class='ident'>BufWriter</span><span class='op'>&lt;</span><span class='ident'>W</span><span class='op'>&gt;</span> {
        <span class='ident'>BufWriter</span>::<span class='ident'>with_capacity</span>(<span class='ident'>DEFAULT_BUF_SIZE</span>, <span class='ident'>inner</span>)
    }

    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>with_capacity</span>(<span class='ident'>cap</span>: <span class='ident'>usize</span>, <span class='ident'>inner</span>: <span class='ident'>W</span>) <span class='op'>-&gt;</span> <span class='ident'>BufWriter</span><span class='op'>&lt;</span><span class='ident'>W</span><span class='op'>&gt;</span> {
        <span class='ident'>BufWriter</span> {
            <span class='ident'>inner</span>: <span class='prelude-val'>Some</span>(<span class='ident'>inner</span>),
            <span class='ident'>buf</span>: <span class='ident'>Vec</span>::<span class='ident'>with_capacity</span>(<span class='ident'>cap</span>),
            <span class='ident'>panicked</span>: <span class='bool-val'>false</span>,
        }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%3CW%3A%20Write%3E%20BufWriter%3CW%3E%20%7B%0A%20%20%20%20pub%20fn%20new(inner%3A%20W)%20-%3E%20BufWriter%3CW%3E%20%7B%0A%20%20%20%20%20%20%20%20BufWriter%3A%3Awith_capacity(DEFAULT_BUF_SIZE%2C%20inner)%0A%20%20%20%20%7D%0A%0A%20%20%20%20pub%20fn%20with_capacity(cap%3A%20usize%2C%20inner%3A%20W)%20-%3E%20BufWriter%3CW%3E%20%7B%0A%20%20%20%20%20%20%20%20BufWriter%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20inner%3A%20Some(inner)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20buf%3A%20Vec%3A%3Awith_capacity(cap)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20panicked%3A%20false%2C%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Note that once created, the capacity of the internal buffer can&#39;t be changed.</p>

<p>As expected, the wrapper implements <code>Write</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>W</span>: <span class='ident'>Write</span><span class='op'>&gt;</span> <span class='ident'>Write</span> <span class='kw'>for</span> <span class='ident'>BufWriter</span><span class='op'>&lt;</span><span class='ident'>W</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>write</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>buf</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>u8</span>]) <span class='op'>-&gt;</span> <span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span> {
        <span class='kw'>if</span> <span class='self'>self</span>.<span class='ident'>buf</span>.<span class='ident'>len</span>() <span class='op'>+</span> <span class='ident'>buf</span>.<span class='ident'>len</span>() <span class='op'>&gt;</span> <span class='self'>self</span>.<span class='ident'>buf</span>.<span class='ident'>capacity</span>() {
            <span class='comment'>// currently, the internal buffer can&#39;t hold all the bytes</span>
            <span class='comment'>// provided by the invocation, so flush the internal buffer</span>
            <span class='self'>self</span>.<span class='ident'>flush_buf</span>()<span class='question-mark'>?</span>;
        }
        <span class='kw'>if</span> <span class='ident'>buf</span>.<span class='ident'>len</span>() <span class='op'>&gt;=</span> <span class='self'>self</span>.<span class='ident'>buf</span>.<span class='ident'>capacity</span>() {
            <span class='comment'>// if the provided bytes&#39;s length is greater than the capacity</span>
            <span class='comment'>// of the internal buffer itself, try to directly deal with the</span>
            <span class='comment'>// inner buffer</span>
            <span class='self'>self</span>.<span class='ident'>panicked</span> <span class='op'>=</span> <span class='bool-val'>true</span>;
            <span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>inner</span>.<span class='ident'>as_mut</span>().<span class='ident'>unwrap</span>().<span class='ident'>write</span>(<span class='ident'>buf</span>);
            <span class='self'>self</span>.<span class='ident'>panicked</span> <span class='op'>=</span> <span class='bool-val'>false</span>;
            <span class='ident'>r</span>
        } <span class='kw'>else</span> {
            <span class='comment'>// the provided bytes can be written into the internal buffer,</span>
            <span class='comment'>// so write it in. This is possible as `Vec&lt;u8&gt;` implements `write`.</span>
            <span class='ident'>Write</span>::<span class='ident'>write</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>.<span class='ident'>buf</span>, <span class='ident'>buf</span>)
        }
    }

    <span class='kw'>fn</span> <span class='ident'>flush</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span> {
        <span class='comment'>// flush the intenal buffer into the underlying buffer,</span>
        <span class='comment'>// then flush the underlying buffer</span>
        <span class='self'>self</span>.<span class='ident'>flush_buf</span>().<span class='ident'>and_then</span>(<span class='op'>|</span>()<span class='op'>|</span> <span class='self'>self</span>.<span class='ident'>get_mut</span>().<span class='ident'>flush</span>())
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%3CW%3A%20Write%3E%20Write%20for%20BufWriter%3CW%3E%20%7B%0A%20%20%20%20fn%20write(%26mut%20self%2C%20buf%3A%20%26%5Bu8%5D)%20-%3E%20io%3A%3AResult%3Cusize%3E%20%7B%0A%20%20%20%20%20%20%20%20if%20self.buf.len()%20%2B%20buf.len()%20%3E%20self.buf.capacity()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20currently%2C%20the%20internal%20buffer%20can't%20hold%20all%20the%20bytes%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20provided%20by%20the%20invocation%2C%20so%20flush%20the%20internal%20buffer%0A%20%20%20%20%20%20%20%20%20%20%20%20self.flush_buf()%3F%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20if%20buf.len()%20%3E%3D%20self.buf.capacity()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20if%20the%20provided%20bytes's%20length%20is%20greater%20than%20the%20capacity%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20of%20the%20internal%20buffer%20itself%2C%20try%20to%20directly%20deal%20with%20the%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20inner%20buffer%0A%20%20%20%20%20%20%20%20%20%20%20%20self.panicked%20%3D%20true%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20r%20%3D%20self.inner.as_mut().unwrap().write(buf)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20self.panicked%20%3D%20false%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20r%0A%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20the%20provided%20bytes%20can%20be%20written%20into%20the%20internal%20buffer%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20so%20write%20it%20in.%20This%20is%20possible%20as%20%60Vec%3Cu8%3E%60%20implements%20%60write%60.%0A%20%20%20%20%20%20%20%20%20%20%20%20Write%3A%3Awrite(%26mut%20self.buf%2C%20buf)%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20fn%20flush(%26mut%20self)%20-%3E%20io%3A%3AResult%3C()%3E%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20flush%20the%20intenal%20buffer%20into%20the%20underlying%20buffer%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20then%20flush%20the%20underlying%20buffer%0A%20%20%20%20%20%20%20%20self.flush_buf().and_then(%7C()%7C%20self.get_mut().flush())%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>For <code>W: Seek</code> it also implements <code>Seek</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>W</span>: <span class='ident'>Write</span> <span class='op'>+</span> <span class='ident'>Seek</span><span class='op'>&gt;</span> <span class='ident'>Seek</span> <span class='kw'>for</span> <span class='ident'>BufWriter</span><span class='op'>&lt;</span><span class='ident'>W</span><span class='op'>&gt;</span> {
    <span class='doccomment'>/// Seek to the offset, in bytes, in the underlying writer.</span>
    <span class='doccomment'>///</span>
    <span class='doccomment'>/// Seeking always writes out the internal buffer before seeking.</span>
    <span class='kw'>fn</span> <span class='ident'>seek</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>pos</span>: <span class='ident'>SeekFrom</span>) <span class='op'>-&gt;</span> <span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>u64</span><span class='op'>&gt;</span> {
        <span class='self'>self</span>.<span class='ident'>flush_buf</span>().<span class='ident'>and_then</span>(<span class='op'>|</span>_<span class='op'>|</span> <span class='self'>self</span>.<span class='ident'>get_mut</span>().<span class='ident'>seek</span>(<span class='ident'>pos</span>))
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%3CW%3A%20Write%20%2B%20Seek%3E%20Seek%20for%20BufWriter%3CW%3E%20%7B%0A%20%20%20%20%2F%2F%2F%20Seek%20to%20the%20offset%2C%20in%20bytes%2C%20in%20the%20underlying%20writer.%0A%20%20%20%20%2F%2F%2F%0A%20%20%20%20%2F%2F%2F%20Seeking%20always%20writes%20out%20the%20internal%20buffer%20before%20seeking.%0A%20%20%20%20fn%20seek(%26mut%20self%2C%20pos%3A%20SeekFrom)%20-%3E%20io%3A%3AResult%3Cu64%3E%20%7B%0A%20%20%20%20%20%20%20%20self.flush_buf().and_then(%7C_%7C%20self.get_mut().seek(pos))%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>The above implementations makes use of a utility function</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>W</span>: <span class='ident'>Write</span><span class='op'>&gt;</span> <span class='ident'>BufWriter</span><span class='op'>&lt;</span><span class='ident'>W</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>flush_buf</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span> {
        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>written</span> <span class='op'>=</span> <span class='number'>0</span>;
        <span class='kw'>let</span> <span class='ident'>len</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>buf</span>.<span class='ident'>len</span>();
        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>ret</span> <span class='op'>=</span> <span class='prelude-val'>Ok</span>(());
        <span class='kw'>while</span> <span class='ident'>written</span> <span class='op'>&lt;</span> <span class='ident'>len</span> {
            <span class='self'>self</span>.<span class='ident'>panicked</span> <span class='op'>=</span> <span class='bool-val'>true</span>;
            <span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>inner</span>.<span class='ident'>as_mut</span>().<span class='ident'>unwrap</span>().<span class='ident'>write</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>.<span class='ident'>buf</span>[<span class='ident'>written</span>...]);
            <span class='self'>self</span>.<span class='ident'>panicked</span> <span class='op'>=</span> <span class='bool-val'>false</span>;

            <span class='kw'>match</span> <span class='ident'>r</span> {
                <span class='prelude-val'>Ok</span>(<span class='number'>0</span>) <span class='op'>=&gt;</span> {
                    <span class='ident'>ret</span> <span class='op'>=</span> <span class='prelude-val'>Err</span>(<span class='ident'>Error</span>::<span class='ident'>new</span>(<span class='ident'>ErrorKind</span>::<span class='ident'>WriteZero</span>, 
                        <span class='string'>&quot;failed to write the buffered data&quot;</span>));
                    <span class='kw'>break</span>;
                }
                <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> <span class='ident'>written</span> <span class='op'>+=</span> <span class='ident'>n</span>,
                <span class='prelude-val'>Err</span>(<span class='kw-2'>ref</span> <span class='ident'>e</span>) <span class='kw'>if</span> <span class='ident'>e</span>.<span class='ident'>kind</span>() <span class='op'>==</span> <span class='ident'>io</span>::<span class='ident'>ErrorKind</span>::<span class='ident'>interrupted</span> <span class='op'>=&gt;</span> {}
                <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> { <span class='ident'>ret</span> <span class='op'>=</span> <span class='prelude-val'>Err</span>(<span class='ident'>e</span>); <span class='kw'>break</span>; }
            }
        }
        <span class='kw'>if</span> <span class='ident'>written</span> <span class='op'>&gt;</span> <span class='number'>0</span> {
            <span class='self'>self</span>.<span class='ident'>buf</span>.<span class='ident'>drain</span>(..<span class='ident'>written</span>); <span class='comment'>// drain the written bytes</span>
        }
        <span class='ident'>ret</span>
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%3CW%3A%20Write%3E%20BufWriter%3CW%3E%20%7B%0A%20%20%20%20fn%20flush_buf(%26mut%20self)%20-%3E%20io%3A%3AResult%3C()%3E%20%7B%0A%20%20%20%20%20%20%20%20let%20mut%20written%20%3D%200%3B%0A%20%20%20%20%20%20%20%20let%20len%20%3D%20self.buf.len()%3B%0A%20%20%20%20%20%20%20%20let%20mut%20ret%20%3D%20Ok(())%3B%0A%20%20%20%20%20%20%20%20while%20written%20%3C%20len%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20self.panicked%20%3D%20true%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20r%20%3D%20self.inner.as_mut().unwrap().write(%26self.buf%5Bwritten...%5D)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20self.panicked%20%3D%20false%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20match%20r%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Ok(0)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20ret%20%3D%20Err(Error%3A%3Anew(ErrorKind%3A%3AWriteZero%2C%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22failed%20to%20write%20the%20buffered%20data%22))%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20break%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Ok(n)%20%3D%3E%20written%20%2B%3D%20n%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Err(ref%20e)%20if%20e.kind()%20%3D%3D%20io%3A%3AErrorKind%3A%3Ainterrupted%20%3D%3E%20%7B%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Err(e)%20%3D%3E%20%7B%20ret%20%3D%20Err(e)%3B%20break%3B%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20if%20written%20%3E%200%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20self.buf.drain(..written)%3B%20%2F%2F%20drain%20the%20written%20bytes%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20ret%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>which attempts to flush the internal buffer&#39;s content into the inner writer. Any error encountered would be returned.</p>

<p>To make sure that the buffered content would be written into the underlying writer when the wrapper goes out of scope, it also implements <code>Drop</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>W</span>: <span class='ident'>Write</span><span class='op'>&gt;</span> <span class='ident'>Drop</span> <span class='kw'>for</span> <span class='ident'>BufWriter</span><span class='op'>&lt;</span><span class='ident'>W</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>drop</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) {
        <span class='kw'>if</span> <span class='self'>self</span>.<span class='ident'>inner</span>.<span class='ident'>is_some</span>() <span class='op'>&amp;&amp;</span> <span class='op'>!</span><span class='self'>self</span>.<span class='ident'>panicked</span> {
            <span class='kw'>let</span> <span class='ident'>_r</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>flush_buf</span>(); <span class='comment'>// dropping shouldn&#39;t panic, so the</span>
                                       <span class='comment'>// returned error (if any) is ignored</span>
        }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%3CW%3A%20Write%3E%20Drop%20for%20BufWriter%3CW%3E%20%7B%0A%20%20%20%20fn%20drop(%26mut%20self)%20%7B%0A%20%20%20%20%20%20%20%20if%20self.inner.is_some()%20%26%26%20!self.panicked%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20_r%20%3D%20self.flush_buf()%3B%20%2F%2F%20dropping%20shouldn't%20panic%2C%20so%20the%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20returned%20error%20(if%20any)%20is%20ignored%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Note that this is also where the <code>panicked</code> flag gets used: when <code>true</code> the flag indicates that the <code>drop</code>ing is because of unwinding which is caused by a panic happened during some <code>writ</code>ing invocation. When this is the case, no further writing should be performed by the <code>drop</code>ing (to prevent double-panic).</p>

<p>It also expose methods for conversions to the underlying writer:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>W</span>: <span class='ident'>Write</span><span class='op'>&gt;</span> <span class='ident'>BufWriter</span><span class='op'>&lt;</span><span class='ident'>W</span><span class='op'>&gt;</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>get_ref</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='ident'>W</span> { <span class='self'>self</span>.<span class='ident'>inner</span>.<span class='ident'>as_ref</span>().<span class='ident'>unwrap</span>() }
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>get_mut</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>W</span> { <span class='self'>self</span>.<span class='ident'>inner</span>.<span class='ident'>as_mut</span>().<span class='ident'>unwrap</span>() }
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>into_inner</span>(<span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>W</span>, <span class='ident'>IntoInnerError</span><span class='op'>&lt;</span><span class='ident'>BufWriter</span><span class='op'>&lt;</span><span class='ident'>W</span><span class='op'>&gt;&gt;</span><span class='op'>&gt;</span> {
        <span class='kw'>match</span> <span class='self'>self</span>.<span class='ident'>flush_buf</span>() {
            <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Err</span>(<span class='ident'>IntoInnerError</span>(<span class='self'>self</span>, <span class='ident'>e</span>)),
            <span class='prelude-val'>Ok</span>(()) <span class='op'>=&gt;</span> <span class='prelude-val'>Ok</span>(<span class='self'>self</span>.<span class='ident'>inner</span>.<span class='ident'>take</span>().<span class='ident'>unwrap</span>())
        }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%3CW%3A%20Write%3E%20BufWriter%3CW%3E%20%7B%0A%20%20%20%20pub%20fn%20get_ref(%26self)%20-%3E%20%26W%20%7B%20self.inner.as_ref().unwrap()%20%7D%0A%20%20%20%20pub%20fn%20get_mut(%26mut%20self)%20-%3E%20%26mut%20W%20%7B%20self.inner.as_mut().unwrap()%20%7D%0A%20%20%20%20pub%20fn%20into_inner(mut%20self)%20-%3E%20Result%3CW%2C%20IntoInnerError%3CBufWriter%3CW%3E%3E%3E%20%7B%0A%20%20%20%20%20%20%20%20match%20self.flush_buf()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20Err(e)%20%3D%3E%20Err(IntoInnerError(self%2C%20e))%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20Ok(())%20%3D%3E%20Ok(self.inner.take().unwrap())%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Note that unlike <code>BufReader</code>, the <code>into_inner</code> method of <code>BufWriter</code> actually <em>does</em> try to flush the buffered content into <code>inner</code>. If the flushing fails, the value of <code>BufWriter</code> as well as the failing <code>Error</code> would be returned inside an <code>IntoInnerError</code>. Also note that this method is the reason why <code>BufWriter&lt;T&gt;</code> wraps around an <code>Option&lt;T&gt;</code> (rather than simply wrapping <code>T</code>). Unlike <code>BufReader&lt;T&gt;</code>, <code>BufWriter</code> implements <code>Drop</code>. As such, it is not allowed to directly move the value of its field out.<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup> Thus another layer of wrapping.</p>

<p>Also note that the wrapper implements <code>Debug</code> if the underlying writer implements <code>Debug</code>.</p>

<h2 id='linewriter' class='section-header'><a href='#linewriter'>LineWriter</a></h2>
<p>The module also provides a <code>LineWriter</code>, which wraps a writer and buffers output to it, flushing whenever a newline character (<code>b&#39;\n&#39;</code>) is encountered.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>LineWriter</span><span class='op'>&lt;</span><span class='ident'>W</span>: <span class='ident'>Write</span><span class='op'>&gt;</span> {
    <span class='ident'>inner</span>: <span class='ident'>BufWriter</span><span class='op'>&lt;</span><span class='ident'>W</span><span class='op'>&gt;</span>,
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20struct%20LineWriter%3CW%3A%20Write%3E%20%7B%0A%20%20%20%20inner%3A%20BufWriter%3CW%3E%2C%0A%7D%0A%7D">Run</a></pre>

<p>To construct it:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>W</span>: <span class='ident'>Write</span><span class='op'>&gt;</span> <span class='ident'>LineWriter</span><span class='op'>&lt;</span><span class='ident'>W</span><span class='op'>&gt;</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>inner</span>: <span class='ident'>W</span>) <span class='op'>-&gt;</span> <span class='ident'>LineWriter</span><span class='op'>&lt;</span><span class='ident'>W</span><span class='op'>&gt;</span> {
        <span class='ident'>LineWriter</span>::<span class='ident'>with_capacity</span>(<span class='number'>1024</span>, <span class='ident'>inner</span>)
    }

    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>with_capacity</span>(<span class='ident'>cap</span>: <span class='ident'>usize</span>, <span class='ident'>inner</span>: <span class='ident'>W</span>) <span class='op'>-&gt;</span> <span class='ident'>LineWriter</span><span class='op'>&lt;</span><span class='ident'>W</span><span class='op'>&gt;</span> {
        <span class='ident'>LineWriter</span> { <span class='ident'>inner</span>: <span class='ident'>BufWriter</span>::<span class='ident'>with_capacity</span>(<span class='ident'>cap</span>, <span class='ident'>inner</span>) }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%3CW%3A%20Write%3E%20LineWriter%3CW%3E%20%7B%0A%20%20%20%20pub%20fn%20new(inner%3A%20W)%20-%3E%20LineWriter%3CW%3E%20%7B%0A%20%20%20%20%20%20%20%20LineWriter%3A%3Awith_capacity(1024%2C%20inner)%0A%20%20%20%20%7D%0A%0A%20%20%20%20pub%20fn%20with_capacity(cap%3A%20usize%2C%20inner%3A%20W)%20-%3E%20LineWriter%3CW%3E%20%7B%0A%20%20%20%20%20%20%20%20LineWriter%20%7B%20inner%3A%20BufWriter%3A%3Awith_capacity(cap%2C%20inner)%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>It implements <code>Write</code> as we&#39;d expect:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>W</span>: <span class='ident'>Write</span><span class='op'>&gt;</span> <span class='ident'>Write</span> <span class='kw'>for</span> <span class='ident'>LineWriter</span><span class='op'>&lt;</span><span class='ident'>W</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>write</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>buf</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>u8</span>]) <span class='op'>-&gt;</span> <span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span> {
        <span class='kw'>match</span> <span class='ident'>memchr</span>::<span class='ident'>memchr</span>(<span class='string'>b&#39;\n&#39;</span>, <span class='ident'>buf</span>) {
            <span class='prelude-val'>Some</span>(<span class='ident'>i</span>) <span class='op'>=&gt;</span> {
                <span class='kw'>let</span> <span class='ident'>n</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>inner</span>.<span class='ident'>write</span>(<span class='kw-2'>&amp;</span><span class='ident'>buf</span>[..<span class='ident'>i</span><span class='op'>+</span><span class='number'>1</span>])<span class='question-mark'>?</span>;
                <span class='kw'>if</span> <span class='ident'>n</span> <span class='op'>!=</span> <span class='ident'>i</span> <span class='op'>+</span> <span class='number'>1</span> <span class='op'>||</span> <span class='self'>self</span>.<span class='ident'>inner</span>.<span class='ident'>flush</span>().<span class='ident'>is_err</span>() {
                    <span class='kw'>return</span> <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>); <span class='comment'>// don&#39;t return errors on partial writes. this is kind of fucked up</span>
                }
                <span class='self'>self</span>.<span class='ident'>inner</span>.<span class='ident'>write</span>(<span class='kw-2'>&amp;</span><span class='ident'>buf</span>[<span class='ident'>i</span><span class='op'>+</span><span class='number'>1</span>..]).<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>i</span><span class='op'>|</span> <span class='ident'>n</span> <span class='op'>+</span> <span class='ident'>i</span>)
            }
            <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='self'>self</span>.<span class='ident'>inner</span>.<span class='ident'>write</span>(<span class='ident'>buf</span>),
        }
    }

    <span class='kw'>fn</span> <span class='ident'>flush</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span> {
        <span class='self'>self</span>.<span class='ident'>inner</span>.<span class='ident'>flush</span>()
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%3CW%3A%20Write%3E%20Write%20for%20LineWriter%3CW%3E%20%7B%0A%20%20%20%20fn%20write(%26mut%20self%2C%20buf%3A%20%26%5Bu8%5D)%20-%3E%20io%3A%3AResult%3Cusize%3E%20%7B%0A%20%20%20%20%20%20%20%20match%20memchr%3A%3Amemchr(b'%5Cn'%2C%20buf)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20Some(i)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20n%20%3D%20self.inner.write(%26buf%5B..i%2B1%5D)%3F%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if%20n%20!%3D%20i%20%2B%201%20%7C%7C%20self.inner.flush().is_err()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20Ok(n)%3B%20%2F%2F%20don't%20return%20errors%20on%20partial%20writes.%20this%20is%20kind%20of%20fucked%20up%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20self.inner.write(%26buf%5Bi%2B1..%5D).map(%7Ci%7C%20n%20%2B%20i)%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20None%20%3D%3E%20self.inner.write(buf)%2C%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20fn%20flush(%26mut%20self)%20-%3E%20io%3A%3AResult%3C()%3E%20%7B%0A%20%20%20%20%20%20%20%20self.inner.flush()%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>It also implements <code>Debug</code> if the underlying writer implements it.</p>

<h1 id='special-adaptors' class='section-header'><a href='#special-adaptors'>Special Adaptors</a></h1>
<p>The module also provides some special reader/writers.</p>

<h2 id='empty' class='section-header'><a href='#empty'>Empty</a></h2>
<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Empty</span> { <span class='ident'>_priv</span>: () }<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20struct%20Empty%20%7B%20_priv%3A%20()%20%7D%0A%7D">Run</a></pre>

<p>The struct implements <code>Read</code> and <code>BufRead</code> as follows:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> <span class='ident'>Read</span> <span class='kw'>for</span> <span class='ident'>Empty</span> {
    <span class='kw'>fn</span> <span class='ident'>read</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>_buf</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='ident'>u8</span>]) <span class='op'>-&gt;</span> <span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span> { <span class='prelude-val'>Ok</span>(<span class='number'>0</span>) }
}

<span class='kw'>impl</span> <span class='ident'>BufRead</span> <span class='kw'>for</span> <span class='ident'>Empty</span> {
    <span class='kw'>fn</span> <span class='ident'>fill_buf</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span>[<span class='ident'>u8</span>]<span class='op'>&gt;</span> { <span class='prelude-val'>Ok</span>(<span class='kw-2'>&amp;</span>[]) }
    <span class='kw'>fn</span> <span class='ident'>consume</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>_n</span>: <span class='ident'>usize</span>) {}
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%20Read%20for%20Empty%20%7B%0A%20%20%20%20fn%20read(%26mut%20self%2C%20_buf%3A%20%26mut%20%5Bu8%5D)%20-%3E%20io%3A%3AResult%3Cusize%3E%20%7B%20Ok(0)%20%7D%0A%7D%0A%0Aimpl%20BufRead%20for%20Empty%20%7B%0A%20%20%20%20fn%20fill_buf(%26mut%20self)%20-%3E%20io%3A%3AResult%3C%26%5Bu8%5D%3E%20%7B%20Ok(%26%5B%5D)%20%7D%0A%20%20%20%20fn%20consume(%26mut%20self%2C%20_n%3A%20usize)%20%7B%7D%0A%7D%0A%7D">Run</a></pre>

<p>Thus, it represents an &quot;empty&quot; reader which will always return EOF.</p>

<p>To construct it, one calls the module level function:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>empty</span>() <span class='op'>-&gt;</span> <span class='ident'>Empty</span> { <span class='ident'>Empty</span> { <span class='ident'>_priv</span>: () } }<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20fn%20empty()%20-%3E%20Empty%20%7B%20Empty%20%7B%20_priv%3A%20()%20%7D%20%7D%0A%7D">Run</a></pre>

<h2 id='repeat' class='section-header'><a href='#repeat'>Repeat</a></h2>
<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Repeat</span> { <span class='ident'>byte</span>: <span class='ident'>u8</span> }<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20struct%20Repeat%20%7B%20byte%3A%20u8%20%7D%0A%7D">Run</a></pre>

<p>The struct implements <code>Read</code> as:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> <span class='ident'>Read</span> <span class='kw'>for</span> <span class='ident'>Repeat</span> {
    <span class='kw'>fn</span> <span class='ident'>read</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>buf</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='ident'>u8</span>]) <span class='op'>-&gt;</span> <span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span> {
        <span class='kw'>for</span> <span class='ident'>slot</span> <span class='kw'>in</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='kw-2'>*</span><span class='ident'>buf</span> {
            <span class='kw-2'>*</span><span class='ident'>slot</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>byte</span>;
        }
        <span class='prelude-val'>Ok</span>(<span class='ident'>buf</span>.<span class='ident'>len</span>())
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%20Read%20for%20Repeat%20%7B%0A%20%20%20%20fn%20read(%26mut%20self%2C%20buf%3A%20%26mut%20%5Bu8%5D)%20-%3E%20io%3A%3AResult%3Cusize%3E%20%7B%0A%20%20%20%20%20%20%20%20for%20slot%20in%20%26mut%20*buf%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20*slot%20%3D%20self.byte%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20Ok(buf.len())%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Thus, it represents a reader which yields one single <code>byte</code> over and over again.</p>

<p>To construct it, one calls the module level function:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>repreat</span>(<span class='ident'>byte</span>: <span class='ident'>u8</span>) <span class='op'>-&gt;</span> <span class='ident'>Repeat</span> { <span class='ident'>Repeat</span> { <span class='ident'>byte</span>: <span class='ident'>byte</span> } }<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20fn%20repreat(byte%3A%20u8)%20-%3E%20Repeat%20%7B%20Repeat%20%7B%20byte%3A%20byte%20%7D%20%7D%0A%7D">Run</a></pre>

<h2 id='sink' class='section-header'><a href='#sink'>Sink</a></h2>
<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Sink</span> { <span class='ident'>_priv</span>: () }<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20struct%20Sink%20%7B%20_priv%3A%20()%20%7D%0A%7D">Run</a></pre>

<p>The struct implements <code>Write</code> as:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> <span class='ident'>Write</span> <span class='kw'>for</span> <span class='ident'>Sink</span> {
    <span class='kw'>fn</span> <span class='ident'>write</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>buf</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>u8</span>]) <span class='op'>-&gt;</span> <span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span> { <span class='prelude-val'>Ok</span>(<span class='ident'>buf</span>.<span class='ident'>len</span>()) }
    <span class='kw'>fn</span> <span class='ident'>flush</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>io</span>::<span class='ident'>Resut</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span> { <span class='prelude-val'>Ok</span>(()) }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%20Write%20for%20Sink%20%7B%0A%20%20%20%20fn%20write(%26mut%20self%2C%20buf%3A%20%26%5Bu8%5D)%20-%3E%20io%3A%3AResult%3Cusize%3E%20%7B%20Ok(buf.len())%20%7D%0A%20%20%20%20fn%20flush(%26mut%20self)%20-%3E%20io%3A%3AResut%3C()%3E%20%7B%20Ok(())%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Thus, it represents a &quot;sink&quot; that can take any input and throw them into the void.</p>

<p>To construct it, one call the module level function</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>sink</span>() <span class='op'>-&gt;</span> <span class='ident'>Sink</span> { <span class='ident'>Sink</span> { <span class='ident'>_priv</span>: () } }<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20fn%20sink()%20-%3E%20Sink%20%7B%20Sink%20%7B%20_priv%3A%20()%20%7D%20%7D%0A%7D">Run</a></pre>

<h2 id='cursor' class='section-header'><a href='#cursor'>Cursor</a></h2>
<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Cursor</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>inner</span>: <span class='ident'>T</span>,
    <span class='ident'>pos</span>: <span class='ident'>u64</span>,
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20struct%20Cursor%3CT%3E%20%7B%0A%20%20%20%20inner%3A%20T%2C%0A%20%20%20%20pos%3A%20u64%2C%0A%7D%0A%7D">Run</a></pre>

<p>The struct is meant to be a wrapper around some other datastream <code>T</code>, providing a &quot;cursor&quot; pointing into it.</p>

<p>Construction is straightforward:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Cursor</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>inner</span>: <span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='ident'>Cursor</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
        <span class='ident'>Cursor</span> { <span class='ident'>pos</span>: <span class='number'>0</span>, <span class='ident'>inner</span>: <span class='ident'>inner</span> }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%3CT%3E%20Cursor%3CT%3E%20%7B%0A%20%20%20%20pub%20fn%20new(inner%3A%20T)%20-%3E%20Cursor%3CT%3E%20%7B%0A%20%20%20%20%20%20%20%20Cursor%20%7B%20pos%3A%200%2C%20inner%3A%20inner%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>For <code>T: AsRef[u8]</code>, which can be considered as a readable datastream, the module provides implementation for <code>BufRead</code> and <code>Seek</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>BufRead</span> <span class='kw'>for</span> <span class='ident'>Cursor</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='kw'>where</span> <span class='ident'>T</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span>[<span class='ident'>u8</span>]<span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>fill_bf</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span>[<span class='ident'>u8</span>]<span class='op'>&gt;</span> {
        <span class='comment'>// `amt` is the index of the next byte available</span>
        <span class='comment'>// the comparison is neccessary, as we don&#39;t guard against</span>
        <span class='comment'>// overflows when incrementing `self.pos`.</span>
        <span class='kw'>let</span> <span class='ident'>amt</span> <span class='op'>=</span> <span class='ident'>cmp</span>::<span class='ident'>min</span>(<span class='self'>self</span>.<span class='ident'>pos</span>, <span class='self'>self</span>.<span class='ident'>inner</span>.<span class='ident'>as_ref</span>().<span class='ident'>len</span>() <span class='kw'>as</span> <span class='ident'>u64</span>);
        <span class='prelude-val'>Ok</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>.<span class='ident'>inner</span>.<span class='ident'>as_ref</span>()[(<span class='ident'>amt</span> <span class='kw'>as</span> <span class='ident'>usize</span>)..])
    }

    <span class='kw'>fn</span> <span class='ident'>consume</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>amt</span>: <span class='ident'>usize</span>) { <span class='self'>self</span>.<span class='ident'>pos</span> <span class='op'>+=</span> <span class='ident'>amt</span> <span class='kw'>as</span> <span class='ident'>u64</span>; }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Read</span> <span class='kw'>for</span> <span class='ident'>Cursor</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='kw'>where</span> <span class='ident'>T</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span>[<span class='ident'>u8</span>]<span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>read</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>buf</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='ident'>u8</span>]) <span class='op'>-&gt;</span> <span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span> {
        <span class='kw'>let</span> <span class='ident'>n</span> <span class='op'>=</span> <span class='ident'>Read</span>::<span class='ident'>read</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>.<span class='ident'>fill_buf</span>()<span class='question-mark'>?</span>, <span class='ident'>buf</span>)<span class='question-mark'>?</span>;
        <span class='self'>self</span>.<span class='ident'>pos</span> <span class='op'>+=</span> <span class='ident'>n</span> <span class='kw'>as</span> <span class='ident'>u64</span>;
        <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>)
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Seek</span> <span class='kw'>for</span> <span class='ident'>Cursor</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='kw'>where</span> <span class='ident'>T</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span>[<span class='ident'>u8</span>]<span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>seek</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>style</span>: <span class='ident'>SeekFrom</span>) <span class='op'>-&gt;</span> <span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>u64</span><span class='op'>&gt;</span> {
        <span class='kw'>let</span> <span class='ident'>pos</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>style</span> {
            <span class='ident'>SeekFrom</span>::<span class='ident'>Start</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> { <span class='self'>self</span>.<span class='ident'>pos</span> <span class='op'>=</span> <span class='ident'>n</span>; <span class='kw'>return</span> <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>); } <span class='comment'>// early return here, caution!</span>
            <span class='ident'>SeekFrom</span>::<span class='ident'>End</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> <span class='self'>self</span>.<span class='ident'>inner</span>.<span class='ident'>as_ref</span>().<span class='ident'>len</span>() <span class='kw'>as</span> <span class='ident'>i64</span> <span class='op'>+</span> <span class='ident'>n</span>;
            <span class='ident'>SeekFrom</span>::<span class='ident'>Current</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> <span class='self'>self</span>.<span class='ident'>pos</span> <span class='kw'>as</span> <span class='ident'>i64</span> <span class='op'>+</span> <span class='ident'>n</span>,
        };

        <span class='kw'>if</span> <span class='ident'>pos</span> <span class='op'>&lt;</span> <span class='number'>0</span> {
            <span class='prelude-val'>Err</span>(<span class='ident'>Error</span>::<span class='ident'>new</span>(<span class='ident'>ErrorKind</span>::<span class='ident'>InvalidInput</span>,
                <span class='string'>&quot;invalid seek to a negative position&quot;</span>));
        } <span class='kw'>else</span> {
            <span class='self'>self</span>.<span class='ident'>pos</span> <span class='op'>=</span> <span class='ident'>pos</span> <span class='kw'>as</span> <span class='ident'>u64</span>;
            <span class='prelude-val'>Ok</span>(<span class='self'>self</span>.<span class='ident'>pos</span>)
        }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%3CT%3E%20BufRead%20for%20Cursor%3CT%3E%20where%20T%3A%20AsRef%3C%5Bu8%5D%3E%20%7B%0A%20%20%20%20fn%20fill_bf(%26mut%20self)%20-%3E%20io%3A%3AResult%3C%26%5Bu8%5D%3E%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20%60amt%60%20is%20the%20index%20of%20the%20next%20byte%20available%0A%20%20%20%20%20%20%20%20%2F%2F%20the%20comparison%20is%20neccessary%2C%20as%20we%20don't%20guard%20against%0A%20%20%20%20%20%20%20%20%2F%2F%20overflows%20when%20incrementing%20%60self.pos%60.%0A%20%20%20%20%20%20%20%20let%20amt%20%3D%20cmp%3A%3Amin(self.pos%2C%20self.inner.as_ref().len()%20as%20u64)%3B%0A%20%20%20%20%20%20%20%20Ok(%26self.inner.as_ref()%5B(amt%20as%20usize)..%5D)%0A%20%20%20%20%7D%0A%0A%20%20%20%20fn%20consume(%26mut%20self%2C%20amt%3A%20usize)%20%7B%20self.pos%20%2B%3D%20amt%20as%20u64%3B%20%7D%0A%7D%0A%0Aimpl%3CT%3E%20Read%20for%20Cursor%3CT%3E%20where%20T%3A%20AsRef%3C%5Bu8%5D%3E%20%7B%0A%20%20%20%20fn%20read(%26mut%20self%2C%20buf%3A%20%26mut%20%5Bu8%5D)%20-%3E%20io%3A%3AResult%3Cusize%3E%20%7B%0A%20%20%20%20%20%20%20%20let%20n%20%3D%20Read%3A%3Aread(%26mut%20self.fill_buf()%3F%2C%20buf)%3F%3B%0A%20%20%20%20%20%20%20%20self.pos%20%2B%3D%20n%20as%20u64%3B%0A%20%20%20%20%20%20%20%20Ok(n)%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%3CT%3E%20Seek%20for%20Cursor%3CT%3E%20where%20T%3A%20AsRef%3C%5Bu8%5D%3E%20%7B%0A%20%20%20%20fn%20seek(%26mut%20self%2C%20style%3A%20SeekFrom)%20-%3E%20io%3A%3AResult%3Cu64%3E%20%7B%0A%20%20%20%20%20%20%20%20let%20pos%20%3D%20match%20style%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20SeekFrom%3A%3AStart(n)%20%3D%3E%20%7B%20self.pos%20%3D%20n%3B%20return%20Ok(n)%3B%20%7D%20%2F%2F%20early%20return%20here%2C%20caution!%0A%20%20%20%20%20%20%20%20%20%20%20%20SeekFrom%3A%3AEnd(n)%20%3D%3E%20self.inner.as_ref().len()%20as%20i64%20%2B%20n%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20SeekFrom%3A%3ACurrent(n)%20%3D%3E%20self.pos%20as%20i64%20%2B%20n%2C%0A%20%20%20%20%20%20%20%20%7D%3B%0A%0A%20%20%20%20%20%20%20%20if%20pos%20%3C%200%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20Err(Error%3A%3Anew(ErrorKind%3A%3AInvalidInput%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22invalid%20seek%20to%20a%20negative%20position%22))%3B%0A%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20self.pos%20%3D%20pos%20as%20u64%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20Ok(self.pos)%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>For <code>T: &amp;&#39;a mut [u8]</code>, <code>T: Vec&lt;u8&gt;</code>, <code>T: Box&lt;[u8]&gt;</code> which can all be considered as writable datastream, the module also implements <code>Write</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> <span class='ident'>Write</span> <span class='kw'>for</span> <span class='ident'>Cursor</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> [<span class='ident'>u8</span>]<span class='op'>&gt;</span> {
    <span class='attribute'>#[<span class='ident'>inline</span>]</span>
    <span class='kw'>fn</span> <span class='ident'>write</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>u8</span>]) <span class='op'>-&gt;</span> <span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span> {
        <span class='kw'>let</span> <span class='ident'>pos</span> <span class='op'>=</span> <span class='ident'>cmp</span>::<span class='ident'>min</span>(<span class='self'>self</span>.<span class='ident'>pos</span>, <span class='self'>self</span>.<span class='ident'>inner</span>.<span class='ident'>len</span>() <span class='kw'>as</span> <span class='ident'>u64</span>);
        <span class='kw'>let</span> <span class='ident'>amt</span> <span class='op'>=</span> (<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>.<span class='ident'>inner</span>[(<span class='ident'>pos</span> <span class='kw'>as</span> <span class='ident'>usize</span>)..]).<span class='ident'>write</span>(<span class='ident'>data</span>)<span class='question-mark'>?</span>;
        <span class='self'>self</span>.<span class='ident'>pos</span> <span class='op'>+=</span> <span class='ident'>amt</span> <span class='kw'>as</span> <span class='ident'>u64</span>;
        <span class='prelude-val'>Ok</span>(<span class='ident'>amt</span>)
    }

    <span class='kw'>fn</span> <span class='ident'>flush</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span> { <span class='prelude-val'>Ok</span>(()) }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%3C'a%3E%20Write%20for%20Cursor%3C%26'a%20mut%20%5Bu8%5D%3E%20%7B%0A%20%20%20%20%23%5Binline%5D%0A%20%20%20%20fn%20write(%26mut%20self%2C%20data%3A%20%26%5Bu8%5D)%20-%3E%20io%3A%3AResult%3Cusize%3E%20%7B%0A%20%20%20%20%20%20%20%20let%20pos%20%3D%20cmp%3A%3Amin(self.pos%2C%20self.inner.len()%20as%20u64)%3B%0A%20%20%20%20%20%20%20%20let%20amt%20%3D%20(%26mut%20self.inner%5B(pos%20as%20usize)..%5D).write(data)%3F%3B%0A%20%20%20%20%20%20%20%20self.pos%20%2B%3D%20amt%20as%20u64%3B%0A%20%20%20%20%20%20%20%20Ok(amt)%0A%20%20%20%20%7D%0A%0A%20%20%20%20fn%20flush(%26mut%20self)%20-%3E%20io%3A%3AResult%3C()%3E%20%7B%20Ok(())%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>The implementation for <code>Cursor&lt;Vec&lt;u8&gt;&gt;</code> and <code>Cursor&lt;Box&lt;[u8]&gt;&gt;</code> are somewhat similar, thus omitted.<sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup></p>

<h1 id='standard-io' class='section-header'><a href='#standard-io'>Standard IO</a></h1>
<p>The module also provides handle structures for standard IO streams of the process.</p>

<h2 id='stdin' class='section-header'><a href='#stdin'>Stdin</a></h2>
<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Stdin</span> { <span class='comment'>/* fields omitted */</span> }<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20struct%20Stdin%20%7B%20%2F*%20fields%20omitted%20*%2F%20%7D%0A%7D">Run</a></pre>

<p>This struct represents a handle to the standard input stream of the process. The handle can be considered as a shared reference to the actual underlying input buffer of the process. Accessing the underlying buffer through this handle is synchronized via a mutex.</p>

<p>To provide such a handle the module exploses a function</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>stdin</span>() <span class='op'>-&gt;</span> <span class='ident'>Stdin</span> { <span class='comment'>/*...*/</span> }<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20fn%20stdin()%20-%3E%20Stdin%20%7B%20%2F*...*%2F%20%7D%0A%7D">Run</a></pre>

<p>The handle implements <code>Read</code> as we&#39;d expect. It also implements</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> <span class='ident'>Stdin</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>read_line</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>buf</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>String</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span> {<span class='comment'>/*...*/</span>}
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%20Stdin%20%7B%0A%20%20%20%20pub%20fn%20read_line(%26self%2C%20buf%3A%20%26mut%20String)%20-%3E%20Result%3Cusize%3E%20%7B%2F*...*%2F%7D%0A%7D%0A%7D">Run</a></pre>

<p>for convinient line-based reading.</p>

<h3 id='stdinlock' class='section-header'><a href='#stdinlock'>StdinLock</a></h3>
<p>Actually, all the reading methods of <code>Stdin</code> is implemented via another struct,</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>StdinLock</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {<span class='comment'>/* fields omitted */</span> }<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20struct%20StdinLock%3C'a%3E%20%7B%2F*%20fields%20omitted%20*%2F%20%7D%0A%7D">Run</a></pre>

<p>The structure represents a locked reference to the standard input buffer. The lock is released when this lock goes out of scope.</p>

<p>To acquire such a lock one invokes</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> <span class='ident'>Stdin</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>lock</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>StdinLock</span> {<span class='comment'>/*...*/</span>}
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%20Stdin%20%7B%0A%20%20%20%20pub%20fn%20lock(%26self)%20-%3E%20StdinLock%20%7B%2F*...*%2F%7D%0A%7D%0A%7D">Run</a></pre>

<p>As the locked reference can have exclusive reading access to the underlying resource, it also implements <code>BufRead</code>.</p>

<h2 id='stdout' class='section-header'><a href='#stdout'>Stdout</a></h2>
<p>On the other side of the spectrum lies</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Stdout</span> { <span class='comment'>/* fields omitted */</span> }<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20struct%20Stdout%20%7B%20%2F*%20fields%20omitted%20*%2F%20%7D%0A%7D">Run</a></pre>

<p>It is a synchronized handle to the standard output stream of the current process.</p>

<p>Likewise, to provide such a handle the module has</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>stdout</span>() <span class='op'>-&gt;</span> <span class='ident'>Stdout</span> {<span class='comment'>/*...*/</span>}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20fn%20stdout()%20-%3E%20Stdout%20%7B%2F*...*%2F%7D%0A%7D">Run</a></pre>

<p>To gain exclusive access to the underlying stream</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> <span class='ident'>Stdout</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>lock</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>StdoutLock</span> {<span class='comment'>/*...*/</span>}
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%20Stdout%20%7B%0A%20%20%20%20pub%20fn%20lock(%26self)%20-%3E%20StdoutLock%20%7B%2F*...*%2F%7D%0A%7D%0A%7D">Run</a></pre>

<p>The <code>Write</code> trait is implemented for this struct as well as its locking counterpart <code>StdoutLock</code>, as we&#39;d expect.</p>

<h1 id='leftovers' class='section-header'><a href='#leftovers'>Leftovers</a></h1>
<p>In addition, the module also provides</p>

<ul>
<li><p><code>copy</code>,
<code>ignore pub fn copy&lt;R, W&gt;(reader: &amp;mut R, writer: &amp;mut W) -&gt; Result&lt;u64&gt; where R: Read + ?Sized, W: Write + ?Sized { let mut buf = [0; DEFAULT_BUF_SIZE]; let mut written = 0; loop { let len = match reader.read(&amp;mut buf) { Ok(0) =&gt; return Ok(written), Ok(len) =&gt; len, Err(ref e) if e.kind() == ErrorKind::Interrupted =&gt; continue, Err(e) =&gt; return Err(e), }; writer.write_all(&amp;buf[..len])?; written += len as u64; } }</code>
The function tries to read the entire contents of a reader and writes it into another reader.</p></li>
<li><p><code>prelude</code> submodule
<code>std::io</code> has a bunch of stuff defined. To alleviate importing many common IO traits, this submodule imports the core traits of <code>io</code>. Concepturally, it is defined as
<code>ignore pub mod prelude { pub use super::Read; pub use super::Write; pub use super::BufRead; pub use super::Seek; }</code></p></li>
</ul>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>To get a furthur explanation check out <a href="https://doc.rust-lang.org/nomicon/destructors.html">The Rustonomicon</a>.&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

<li id="fn2">
<p>Actually, no. The implementation for <code>Cursor&lt;Vec&lt;u8&gt;&gt;</code> is a bit more complicated, as it tries to resize the vector to fit in all the bytes provided.&nbsp;<a href="#fnref2" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

    <script src='rustbook.js'></script>
</div></div>


</body>
</html>