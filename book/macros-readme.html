<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Macros in std</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ol class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a class='active' href='macros-readme.html'><b>2.</b> Macros in std</a>
</li>
</ol>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Macros in std</h1>
    <p>Lists all the macros defined in <code>std</code>.</p>

<p>TODO:</p>

<ul>
<li>[x] categorize them.</li>
<li>[ ] add examples for the formatting macros, maybe referencing a standalone post on formatting.</li>
<li>[ ] introduce unstable macros.</li>
</ul>

<h1 id='panic' class='section-header'><a href='#panic'>Panic!</a></h1>
<p>First comes the Mighty Panic.</p>

<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.panic.html"><code>panic!</code></a></p>

<p>Injects panic into the calling thread, causing it to panic entirely.</p>

<p>Panic can be reaped as a <code>Box&lt;Any&gt;</code>.</p>

<p>Single-argument form transmits the argument, multi-argument form effectively forwards the argument to a <code>format!</code> call and transmits the returned <code>String</code>.</p>
</blockquote>

<h1 id='formatting' class='section-header'><a href='#formatting'>Formatting</a></h1>
<p>These macros are used to <code>format</code> a <code>String</code>; <code>write</code> the result to some buffer; specifically, <code>print</code> to the standard output.</p>

<p>These are among the most widely used and well-known macros defined in <code>std</code> rust, thus should be covered here first. However, the actual formatting syntax they depend on is somewhat involved, and thus will be introduced in a separate post about <a href="TODO"><code>std::fmt</code></a>.<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup></p>

<p>Some other macros(such as <code>assert!</code>) also utilize the formatting syntax, but as formatting is not their primary concern, they are not put under this category.</p>

<p>reference to the correpsonding chapter in <a href="http://rustbyexample.com/hello/print.html">Rust by Example</a></p>

<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.format.html"><code>format!</code></a></p>

<p>Use the syntax described in <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a> to create a value of <code>String</code>.</p>

<p>[<code>format_args!</code>]</p>

<p>The core macro for formatted string creation. Generally not used externally.</p>

<p><a href="https://doc.rust-lang.org/std/macro.write.html"><code>write!</code></a></p>

<p>Write formatted data into a buffer.</p>

<p>The macro accepts a &#39;writer&#39; (any value with a <code>write_fmt</code> method).</p>

<p>The <code>write_fmt</code> method usually comes from implementation of <code>std::fmt::Write</code> or <code>std::io::Write</code> traits.</p>

<p>Additional arguments will be formatted as presented to a <code>format!</code>.</p>

<p>Returns whatever the <code>write_fmt</code> method returns, common return values include <code>std::fmt::Result</code> of <code>std::io::Result</code>.</p>

<p><a href="https://doc.rust-lang.org/std/macro.writeln.html"><code>writeln!</code></a></p>

<p>Similar to <code>write!</code>, but appends a newline character.</p>

<p>The newline character is the LINE FEED character(<code>\n</code>, <code>U+000A</code>).</p>

<p><a href="https://doc.rust-lang.org/std/macro.print.html"><code>print!</code></a></p>

<p>Prints to the standard output using <code>format!</code> to format the input.</p>

<p>Panics if writing fails.</p>

<p><a href="https://doc.rust-lang.org/std/macro.println.html"><code>println!</code></a></p>

<p>Similar to <code>print!</code>, but appends a newline character.</p>

<p>The newline character is the LINE FEED character(<code>\n</code>, <code>U+000A</code>).</p>
</blockquote>

<h1 id='assertions' class='section-header'><a href='#assertions'>Assertions</a></h1>
<p>Assertions are runtime checks that once failed would <code>panic</code> the calling thread. They are used to check core invariants that shouldn&#39;t be violated. Also useful during testing.</p>

<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.assert.html"><code>assert!</code></a></p>

<p>Ensures that a boolean expression evaluates to <code>true</code> at runtime. If not, <code>panic!</code>.</p>

<p>Always checked, no matter what the build settings are. <code>debug_assert!</code> is for assertions that are not enabled in release builds by default.</p>

<p>Additional arguments to the macro will be sent to <code>format!</code> to provide a custom panic message.</p>

<p>Usage:</p>

<ul>
<li>Enforce runtime invariants (esp. for unsafe code).</li>
<li><a href="https://doc.rust-lang.org/book/testing.html">testing</a></li>
</ul>

<p><a href="https://doc.rust-lang.org/std/macro.assert_eq.html"><code>assert_eq!</code></a></p>

<p>Similar to <code>assert!($left_expr != $right_expr)</code>.</p>

<p><a href="https://doc.rust-lang.org/std/macro.assert_ne.html"><code>assert_ne!</code></a></p>

<p>Similar to <code>assert!($left_expr == $right_expr)</code>.</p>

<p><a href="https://doc.rust-lang.org/std/macro.concat.html"><code>debug_assert!</code></a></p>

<p><a href="https://doc.rust-lang.org/std/macro.debug_assert_eq.html"><code>debug_assert_eq!</code></a></p>

<p><a href="https://doc.rust-lang.org/std/macro.debug_assert_ne.html"><code>debug_assert_ne!</code></a></p>

<p>Analogies for <code>assert!</code>s, but are only evaluated in debug builds by default.</p>

<p>If <code>-C debug-assertions</code> is passed to the compiler, these assertions won&#39;t be optimized.</p>
</blockquote>

<h1 id='threading' class='section-header'><a href='#threading'>Threading</a></h1>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.thread_local.html"><code>thread_local</code></a></p>

<p>Declares a new thread local storage key of type <code>std::thread::LocalKey</code>.</p>

<p>The macro wraps any number of static delcarations and makes them thread local.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cell</span>::<span class='ident'>RefCell</span>;
<span class='macro'>thread_local</span><span class='macro'>!</span> {
  <span class='kw'>pub</span> <span class='kw'>static</span> <span class='ident'>FOO</span>: <span class='ident'>RefCell</span><span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>RefCell</span>::<span class='ident'>new</span>(<span class='number'>1</span>);
  <span class='attribute'>#[<span class='ident'>allow</span>(<span class='ident'>unused</span>)]</span>
  <span class='kw'>static</span> <span class='ident'>BAR</span>: <span class='ident'>RefCell</span><span class='op'>&lt;</span><span class='ident'>f32</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>RefCell</span>::<span class='ident'>new</span>(<span class='number'>1.0</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Ause%20std%3A%3Acell%3A%3ARefCell%3B%0Athread_local!%20%7B%0A%20%20pub%20static%20FOO%3A%20RefCell%3Cu32%3E%20%3D%20RefCell%3A%3Anew(1)%3B%0A%20%20%23%5Ballow(unused)%5D%0A%20%20static%20BAR%3A%20RefCell%3Cf32%3E%20%3D%20RefCell%3A%3Anew(1.0)%3B%0A%7D%0A%7D">Run</a></pre>
</blockquote>

<h1 id='vector-construction' class='section-header'><a href='#vector-construction'>Vector Construction</a></h1>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.vec.html"><code>vec!</code></a></p>

<p>Creates a <code>Vec</code> containing the arguments, allowing <code>Vec</code> to be defined with the same syntax as array exprs. It can</p>

<ul>
<li><p>Create a <code>Vec</code> containing a given list of elements.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>[<span class='number'>1</span>], <span class='number'>2</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20v%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0Aassert_eq!(v%5B1%5D%2C%202)%3B%0A%7D">Run</a></pre></li>
<li><p>Create a <code>Vec</code> from a given element and size:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>; <span class='number'>3</span>];
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='number'>1</span>, <span class='number'>1</span>, <span class='number'>1</span>]);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20v%20%3D%20vec!%5B1%3B%203%5D%3B%0Aassert_eq!(v%2C%20%5B1%2C%201%2C%201%5D)%3B%0A%7D">Run</a></pre></li>
</ul>

<p>Unlike array exprs, this supports all elements implementing <code>Clone</code>.</p>

<p>This will use <code>clone()</code> to duplicate an expression.</p>
</blockquote>

<h1 id='the-once-mighty-try' class='section-header'><a href='#the-once-mighty-try'>The Once Mighty <code>try!</code></a></h1>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.try.html"><code>try!</code></a></p>

<p>Matches a <code>Result</code>. If <code>Ok</code>, expands to the wrapped value. If <code>Err</code>, retrieves the inner error, and returned it. Thus it can only be used in functions returning a <code>Result</code>.</p>

<p>This was once a popular macro. In fact, it was so popular, that the Rust team decided to introduce it into the core syntax, using <code>?</code>. Now we should always prefer using <code>?</code>.</p>
</blockquote>

<h1 id='panicing-markers' class='section-header'><a href='#panicing-markers'>Panicing Markers</a></h1>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.unimplemented.html"><code>unimplemented!</code></a></p>

<p>A standardized placeholder for marking unfinished code.</p>

<p>When executed, panics with msg <code>&quot;not yet implemented&quot;</code>.</p>

<p><a href="https://doc.rust-lang.org/std/macro.unreachable.html"><code>unreachable!</code></a></p>

<p>Indicating unreachable code.</p>

<p>Useful when compiler can&#39;t determine if the code is unreachable. e.g. when:</p>

<ul>
<li>Match arms with guard conditions.</li>
<li>Loops that dynamically terminate.</li>
<li>Iterators that dynamically terminate.</li>
</ul>

<p>When executed, always panics.</p>
</blockquote>

<h1 id='compile-time-str-generation' class='section-header'><a href='#compile-time-str-generation'>Compile-time str generation</a></h1>
<p>These macros can take some input tokens and turns them to some specific <code>&amp;&#39;static str</code>s during compile time.</p>

<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.concat.html"><code>concat!</code></a></p>

<p>Concatenates literals into a <code>&amp;&#39;static str</code>. Integers and floating points would be stringified.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='macro'>concat</span><span class='macro'>!</span>(<span class='string'>&quot;test&quot;</span>, <span class='number'>10</span>, <span class='string'>&#39;b&#39;</span>, <span class='bool-val'>true</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>, <span class='string'>&quot;test10btrue&quot;</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20s%20%3D%20concat!(%22test%22%2C%2010%2C%20'b'%2C%20true)%3B%0Aassert_eq!(s%2C%20%22test10btrue%22)%3B%0A%7D">Run</a></pre>

<p><a href="https://doc.rust-lang.org/std/macro.stringify.html"><code>stringify!</code></a></p>

<p>Stringifies the argument, yielding an expression of type <code>&amp;&#39;static str</code>, which is the stringification of all the input tokens.</p>

<p>The expanded result is subjected to changes in the future, thus should not be relied on.</p>

<pre class='rust rust-example-rendered'>
<span class='comment'>// That said, we do rely on its output in the example.</span>
<span class='kw'>let</span> <span class='ident'>one_p_one</span> <span class='op'>=</span> <span class='macro'>stringify</span><span class='macro'>!</span>(<span class='number'>1</span> <span class='op'>+</span> <span class='number'>1</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>one_p_one</span>, <span class='string'>&quot;1 + 1&quot;</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%2F%2F%20That%20said%2C%20we%20do%20rely%20on%20its%20output%20in%20the%20example.%0Alet%20one_p_one%20%3D%20stringify!(1%20%2B%201)%3B%0Aassert_eq!(one_p_one%2C%20%221%20%2B%201%22)%3B%0A%7D">Run</a></pre>

<p><a href="https://doc.rust-lang.org/std/macro.env.html"><code>env!</code></a></p>

<p>Inspect environment variables at compile time, yielding an <code>&amp;&#39;static str</code>.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>path</span> <span class='op'>=</span> <span class='macro'>env</span><span class='macro'>!</span>(<span class='string'>&quot;PATH&quot;</span>);
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The PATH variable at the time of compiling was: {}&quot;</span>, <span class='ident'>path</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20path%20%3D%20env!(%22PATH%22)%3B%0Aprintln!(%22The%20PATH%20variable%20at%20the%20time%20of%20compiling%20was%3A%20%7B%7D%22%2C%20path)%3B%0A%7D">Run</a></pre>

<p><a href="https://doc.rust-lang.org/std/macro.option_env.html"><code>option_env!</code></a></p>

<p>Similar to <code>env!</code>, but returns an <code>Option&lt;&amp;&#39;static str&gt;</code> instead, <code>None</code> if the environment variable is not presented.</p>

<p><a href="https://doc.rust-lang.org/std/macro.file.html"><code>file!</code></a></p>

<p>Expands to the file name from which it was invoked, yielding an <code>&amp;&#39;static str</code>.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>this_filename</span> <span class='op'>=</span> <span class='macro'>file</span><span class='macro'>!</span>();
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;defined in file: {}&quot;</span>, <span class='ident'>this_filename</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20this_filename%20%3D%20file!()%3B%0Aprintln!(%22defined%20in%20file%3A%20%7B%7D%22%2C%20this_filename)%3B%0A%7D">Run</a></pre>
</blockquote>

<h1 id='meta-information' class='section-header'><a href='#meta-information'>Meta Information</a></h1>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.cfg.html"><code>cfg!</code></a></p>

<p>Boolean evaluation of configuration flags.</p>

<p>Syntax given to this macro is the same syntax as <a href="https://doc.rust-lang.org/reference.html#conditional-compilation">the <code>cfg</code> attribute</a>.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>my_dir</span> <span class='op'>=</span> <span class='kw'>if</span> <span class='macro'>cfg</span><span class='macro'>!</span>(<span class='ident'>windows</span>) {
  <span class='string'>&quot;windows-specified-dir&quot;</span>
} <span class='kw'>else</span> {
  <span class='string'>&quot;unix-dir&quot;</span>
};<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20my_dir%20%3D%20if%20cfg!(windows)%20%7B%0A%20%20%22windows-specified-dir%22%0A%7D%20else%20%7B%0A%20%20%22unix-dir%22%0A%7D%3B%0A%7D">Run</a></pre>

<p><a href="https://doc.rust-lang.org/std/macro.column.html"><code>column!</code></a></p>

<p>Expands to the colunmn number on which it was invoked, yielding a <code>u32</code>.</p>

<p><a href="https://doc.rust-lang.org/std/macro.line.html"><code>line!</code></a></p>

<p>Expands to the line number on which it was invoked, yielding a <code>u32</code>.</p>

<p><a href="https://doc.rust-lang.org/std/macro.module_path.html"><code>module_path!</code></a></p>

<p>Expands to a string that represents the current module path, which is a hierarchy of modules leading back up to the crate root.</p>

<p>The first component of the path returned is the name of the crate currently being compiled.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>test</span> {
  <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>foo</span>() {
    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='macro'>module_path</span><span class='macro'>!</span>().<span class='ident'>ends_with</span>(<span class='string'>&quot;test&quot;</span>));
  }
}

<span class='ident'>test</span>::<span class='ident'>foo</span>();<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Amod%20test%20%7B%0A%20%20pub%20fn%20foo()%20%7B%0A%20%20%20%20assert!(module_path!().ends_with(%22test%22))%3B%0A%20%20%7D%0A%7D%0A%0Atest%3A%3Afoo()%3B%0A%7D">Run</a></pre>
</blockquote>

<h1 id='includes' class='section-header'><a href='#includes'>Includes</a></h1>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/macro.include.html"><code>include!</code></a></p>

<p>Parse a file as an expression or an item according to context.</p>

<p>Path is located relative to the current file.</p>

<p>Using this macro is often considered a bad idea.</p>

<p><a href="https://doc.rust-lang.org/std/macro.include_bytes.html"><code>include_bytes!</code></a></p>

<p>Include a file as a reference to a byte array, yielding a <code>&amp;&#39;static [u8; N]</code> which is the contents of the referenced file.</p>

<p>Path is located relative to the current file.</p>

<p><a href="https://doc.rust-lang.org/std/macro.include_str.html"><code>include_str!</code></a></p>

<p>Include a utf8 encoded file as a string, yielding a <code>&amp;&#39;static str</code> which is the contents of the referenced file.</p>

<p>Path is located relative to the current file.</p>
</blockquote>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
</li>

</ol>
</div>

    <script src='rustbook.js'></script>
</div></div>


</body>
</html>